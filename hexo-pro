yarn 1.22.22
const login_api = require('./login_api');
const post_api = require('./post_api')
const page_api = require('./page_api')
const image_api = require('./image_api') // 添加图片API
const yaml_api = require('./yaml_api');
const dashboard_api = require('./dashboard_api'); // 添加仪表盘API
const deploy_api = require('./deploy_api'); // 添加部署API
const settings_api = require('./settings_api'); // 添加设置API
const auth_api = require('./auth_api'); // 添加认证API
const CircularJSON = require('circular-json');
const crypto = require('crypto');
const { expressjwt: jwt } = require('express-jwt'); // 确保引入 express-jwt
const bodyParser = require('body-parser');
const databaseManager = require('./database-manager'); // 导入数据库管理器

// Helper function to promisify NeDB methods
function promisifyNeDB(db, method, ...args) {
  return new Promise((resolve, reject) => {
    db[method](...args, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}

module.exports = async function (app, hexo) { // 将导出函数改为 async

    app.use('/hexopro/api', bodyParser.json({ limit: '50mb' }));
    app.use('/hexopro/api', bodyParser.urlencoded({ extended: true }));

    var use = function (path, fn) {
        // 检查路径中是否包含参数（如 :id）
        if (path.includes(':')) {
            // 将 :param 转换为正则表达式 ([^/]+)
            const paramNames = [];
            const regexPath = path.replace(/:([^/]+)/g, (match, paramName) => {
                paramNames.push(paramName);
                return '([^/]+)';
            });
            
            // 创建正则表达式对象
            const rootPrefix = hexo.config.root || '/'; // 处理 root 可能为空或 / 的情况
            const apiBasePath = `${rootPrefix}hexopro/api/`.replace('//', '/'); // 确保只有一个斜杠
            const pathRegex = new RegExp('^' + apiBasePath + regexPath + '$');
            
            app.use(function (req, res, next) {
                // 检查请求路径是否匹配正则表达式
                const match = req.url.split('?')[0].match(pathRegex);
                if (match) {
                    // 如果匹配，提取参数值并添加到 req.params
                    req.params = req.params || {};
                    for (let i = 0; i < paramNames.length; i++) {
                        req.params[paramNames[i]] = match[i + 1];
                    }
                    
                    // 设置 done 和 send 方法
                    var done = function (val) {
                        if (!val) {
                            res.statusCode = 204
                            return res.end('');
                        }
                        res.setHeader('Content-type', 'application/json')
                        res.end(CircularJSON.stringify(val))
                    }
                    res.done = done
                    res.send = function (num, data) {
                        res.statusCode = num
                        res.end(data)
                    }
                    
                    // 调用处理函数
                    fn(req, res, next);
                } else {
                    // 如果不匹配，继续下一个中间件
                    next();
                }
            });
        } else {
            // 对于没有参数的路径，修改为精确匹配
            const rootPrefix = hexo.config.root || '/'; // 处理 root 可能为空或 / 的情况
            const apiBasePath = `${rootPrefix}hexopro/api/`.replace('//', '/'); // 确保只有一个斜杠
            const exactPath = apiBasePath + path;
            
            app.use(exactPath, function (req, res, next) {
                // 确保路径完全匹配，避免子路径被拦截
                // 修改这里的逻辑以正确处理根路径和查询参数
                const requestPath = req.originalUrl.split('?')[0];
                if (requestPath !== exactPath) {
                     return next();
                }
                
                var done = function (val) {
                    if (!val) {
                        res.statusCode = 204
                        return res.end('');
                    }
                    res.setHeader('Content-type', 'application/json')
                    res.end(CircularJSON.stringify(val))
                }
                res.done = done
                res.send = function (num, data) {
                    res.statusCode = num
                    res.end(data)
                }
                fn(req, res, next)
            })
        }
    }
    
    // 将actualNeedLogin和jwtSecret设为全局变量，以便其他模块可以访问
    global.actualNeedLogin = false;
    global.jwtSecret = null;

    try {
        // --- 使用数据库管理器初始化数据库 ---
        console.log('[Hexo Pro API]: 初始化数据库...');
        const db = await databaseManager.initialize(hexo);
        console.log('[Hexo Pro API]: 数据库初始化完成');

        // --- 检查用户数量并设置认证状态 ---
        const count = await promisifyNeDB(db.userDb, 'count', {});
        console.log('[Hexo Pro API]: 用户数量检查完成, count:', count);

        if (count > 0) {
            global.actualNeedLogin = true;
            console.log('[Hexo Pro API]: 数据库中存在用户，启用登录验证');

            // 获取或生成 JWT secret
            let settings = await promisifyNeDB(db.settingsDb, 'findOne', { type: 'system' });
            console.log('[Hexo Pro API]: 系统设置检查完成');

            if (settings && settings.jwtSecret) {
                global.jwtSecret = settings.jwtSecret;
                console.log('[Hexo Pro API]: 从数据库加载 JWT 密钥');
            } else {
                // 生成新的 JWT secret
                global.jwtSecret = crypto.randomBytes(64).toString('hex');
                console.log('[Hexo Pro API]: 生成新的 JWT 密钥');

                // 保存到数据库
                const systemSettingUpdate = {
                    type: 'system',
                    jwtSecret: global.jwtSecret,
                    updatedAt: new Date()
                };
                if (!settings) {
                    systemSettingUpdate.createdAt = new Date();
                    await promisifyNeDB(db.settingsDb, 'insert', systemSettingUpdate);
                    console.log('[Hexo Pro API]: 新 JWT 密钥已保存到数据库 (insert)');
                } else {
                    await promisifyNeDB(db.settingsDb, 'update', { type: 'system' }, { $set: systemSettingUpdate }, {});
                    console.log('[Hexo Pro API]: 新 JWT 密钥已保存到数据库 (update)');
                }
            }
        } else {
            console.log('[Hexo Pro API]: 数据库中没有用户，无需登录验证');
        }

        // --- 在数据库检查完成后配置 JWT 中间件和路由 ---
        const rootPrefix = hexo.config.root || '/'; // 处理 root 可能为空或 / 的情况
        const apiBasePath = `${rootPrefix}hexopro/api`.replace('//', '/'); // API基础路径
        const unlessPaths = [
            `${apiBasePath}/login`,
            `${apiBasePath}/settings/check-first-use`,
            `${apiBasePath}/settings/register`,
            `${apiBasePath}/settings/skip-setup`, // 添加跳过设置API到排除列表
            `${apiBasePath}/auth/status`, // 添加认证状态检查路径到排除列表
            `${apiBasePath}/desktop/status`, // 添加桌面端状态API到排除列表
            `${apiBasePath}/desktop/auth-check`, // 添加桌面端认证检查API到排除列表  
            `${apiBasePath}/desktop/save-token` // 添加桌面端保存token API到排除列表
        ];


        if (global.actualNeedLogin) {
            console.log('启用JWT验证，secret:', global.jwtSecret ? '已设置' : '未设置');
            console.log('排除的路径:', unlessPaths);

            if (!global.jwtSecret) {
                 // 理论上不应该发生，因为上面已经处理了生成逻辑
                console.error('[Hexo Pro API]: 严重错误 - JWT Secret 未能生成或加载!');
                global.jwtSecret = crypto.randomBytes(64).toString('hex'); // 再次尝试生成以防万一
            }

            // 使用更简单的路径匹配方式
            app.use(apiBasePath, jwt({ // 应用于 /hexopro/api 基础路径
                secret: global.jwtSecret,
                algorithms: ["HS256"],
                requestProperty: 'auth' // 确保将解码后的token信息存储在req.auth中
            }).unless({ path: unlessPaths })); // 排除特定路径
        } else {
             console.log('[Hexo Pro API]: 未启用JWT验证');
        }

        // 注册所有 API 路由
        login_api(app, hexo, use, db); // 移除不再需要的参数
        post_api(app, hexo, use);
        page_api(app, hexo, use);
        image_api(app, hexo, use); // 注册图片API
        yaml_api(app, hexo, use);
        dashboard_api(app, hexo, use); // 注册仪表盘API
        deploy_api(app, hexo, use, db); // 传递数据库实例到部署API
        settings_api(app, hexo, use, db); // 注册设置API
        auth_api(app, hexo, use); // 注册认证API


        app.use((err, req, res, next) => {
            if (err.name === 'UnauthorizedError') {
                console.error('[Hexo Pro API]: token 验证失败:', err.message); // 添加日志记录
                res.setHeader('Content-type', 'application/json')
                res.statusCode = 200 // 或者 401
                res.end(JSON.stringify({ code: 401, msg: 'token unauthorized' })) // 修正拼写
            } else {
                console.error('[Hexo Pro API]: 未知错误:', err.message); // 添加日志记录
                res.setHeader('Content-type', 'application/json')
                res.statusCode = 500
                res.end(JSON.stringify({ code: 500, msg: 'unknown err:' + err.message })) // 返回错误消息
            }
        })

    } catch (err) {
        console.error('[Hexo Pro API]: API 初始化失败:', err);
        // 可以在这里添加错误处理逻辑，例如阻止服务器启动或返回错误状态
    }

    // 返回实际的 needLogin 状态和 JWT secret (虽然现在是全局的，但保持返回可能对某些调用有用)
    return {
        needLogin: global.actualNeedLogin,
        jwtSecret: global.jwtSecret
    };
};module.exports = function (app, hexo, use) {
    
    /**
     * 验证token有效性
     * GET /hexopro/api/auth/validate
     */
    use('auth/validate', function (req, res) {
        try {
            // 如果请求能到达这里，说明JWT中间件已经验证了token
            // req.auth 包含解码后的token信息（由express-jwt设置）
            
            if (req.auth && req.auth.userId) {
                // token有效，返回用户基本信息
                res.done({
                    valid: true,
                    userId: req.auth.userId,
                    username: req.auth.username,
                    message: 'Token验证成功'
                });
            } else {
                // 理论上不会到达这里，因为JWT中间件会先拦截
                res.send(401, 'Token验证失败');
            }
        } catch (error) {
            console.error('Token验证过程中出错:', error);
            res.send(500, 'Token验证失败');
        }
    });

    /**
     * 获取当前用户信息
     * GET /hexopro/api/auth/user
     */
    use('auth/user', function (req, res) {
        try {
            if (req.auth && req.auth.userId) {
                res.done({
                    userId: req.auth.userId,
                    username: req.auth.username,
                    role: req.auth.role || 'user',
                    message: '获取用户信息成功'
                });
            } else {
                res.send(401, '未授权访问');
            }
        } catch (error) {
            console.error('获取用户信息失败:', error);
            res.send(500, '获取用户信息失败');
        }
    });

    /**
     * 检查权限状态（无需token）
     * GET /hexopro/api/auth/status
     */
    use('auth/status', function (req, res) {
        try {
            // 这个接口不需要token验证，用于检查系统是否启用了认证
            res.done({
                authEnabled: global.actualNeedLogin || false,
                message: global.actualNeedLogin ? '系统已启用认证' : '系统未启用认证'
            });
        } catch (error) {
            console.error('获取认证状态失败:', error);
            res.send(500, '获取认证状态失败');
        }
    });

    /**
     * 刷新token（可选功能）
     * POST /hexopro/api/auth/refresh
     */
    use('auth/refresh', function (req, res, next) {
        if (req.method !== 'POST') return next();
        
        try {
            if (req.auth && req.auth.userId) {
                const jwt = require('jsonwebtoken');
                
                // 生成新的token
                const newToken = jwt.sign(
                    { 
                        userId: req.auth.userId, 
                        username: req.auth.username,
                        role: req.auth.role || 'user'
                    },
                    global.jwtSecret,
                    { expiresIn: '7d' }
                );

                res.done({
                    token: newToken,
                    expiresIn: '7d',
                    message: 'Token刷新成功'
                });
            } else {
                res.send(401, '未授权访问');
            }
        } catch (error) {
            console.error('刷新token失败:', error);
            res.send(500, '刷新token失败');
        }
    });
}; const path = require('path')
const fs = require('hexo-fs')
const fse = require('fs-extra');
const _ = require('lodash')
const axios = require('axios'); // 需要安装axios

module.exports = function (app, hexo, use) {
    // 获取文章统计数据
    use('dashboard/posts/stats', function (req, res) {
        try {
            const posts = hexo.model('Post').toArray()
            const total = posts.length
            const drafts = posts.filter(post => post.source && post.source.indexOf('_draft') === 0).length
            const published = total - drafts

            res.done({
                total: total,
                drafts: drafts,
                published: published
            })
        } catch (error) {
            console.error('获取文章统计失败:', error)
            res.send(500, '获取文章统计失败')
        }
    })

    // 获取分类统计
    use('dashboard/categories/list', function (req, res) {
        try {
            const categories = []
            hexo.model('Category').forEach(function (category) {
                if (category.posts.length == 0) {
                    return 
                }
                categories.push({
                    name: category.name,
                    count: category.posts.length,
                    path: category.path
                })
            })

            // 按文章数量排序
            const sortedCategories = _.sortBy(categories, 'count').reverse()
            res.done(sortedCategories)
        } catch (error) {
            console.error('获取分类统计失败:', error)
            res.send(500, '获取分类统计失败')
        }
    })

    // 获取标签统计
    use('dashboard/tags/list', function (req, res) {
        try {
            const tags = []
            hexo.model('Tag').forEach(function (tag) {
                tags.push({
                    name: tag.name,
                    count: tag.posts.length,
                    path: hexo.config.url + '/' + tag.path
                })
            })

            // 按文章数量排序
            const sortedTags = _.sortBy(tags, 'count').reverse()
            res.done(sortedTags)
        } catch (error) {
            console.error('获取标签统计失败:', error)
            res.send(500, '获取标签统计失败')
        }
    })

    // 获取最近文章
    use('dashboard/posts/recent', function (req, res) {
        try {
            const parsedUrl = new URL(req.url, hexo.config.url)
            const limit = parseInt(parsedUrl.searchParams.get('limit')) || 5
            const sortBy = parsedUrl.searchParams.get('sortBy') || 'date'

            const posts = hexo.model('Post').toArray()

            // 根据排序字段选择排序方式
            const sortedPosts = _.sortBy(posts, post => {
                if (sortBy === 'updated') {
                    return -new Date(post.updated || post.date)
                }
                return -new Date(post.date)
            })

            // 限制返回数量
            const recentPosts = sortedPosts.slice(0, limit).map(post => {
                // 添加isDraft属性
                const isDraft = post.source && post.source.indexOf('_draft') === 0

                // 只返回需要的字段，并格式化日期
                return {
                    title: post.title,
                    permalink: post.permalink,
                    date: formatDateTime(post.date),
                    updated: post.updated ? formatDateTime(post.updated) : null,
                    isDraft: isDraft
                }
            })

            res.done(recentPosts)
        } catch (error) {
            console.error('获取最近文章失败:', error)
            res.send(500, '获取最近文章失败')
        }
    })

    // 获取系统信息
    use('dashboard/system/info', function (req, res) {
        try {
            // 读取package.json获取Hexo版本
            const packagePath = path.join(hexo.base_dir, 'node_modules/hexo/package.json')
            let hexoVersion = 'Unknown'
            if (fs.existsSync(packagePath)) {
                const packageInfo = JSON.parse(fs.readFileSync(packagePath))
                hexoVersion = packageInfo.version
            }

            // 获取当前主题
            const theme = hexo.config.theme || 'Unknown'

            // 获取作者信息
            const author = hexo.config.author || ''

            // 获取插件列表
            const plugins = []
            const pluginsDir = path.join(hexo.base_dir, 'node_modules')
            if (fs.existsSync(pluginsDir)) {
                const dirs = fs.readdirSync(pluginsDir)
                dirs.forEach(dir => {
                    if (dir.startsWith('hexo-')) {
                        const pluginPackagePath = path.join(pluginsDir, dir, 'package.json')
                        if (fs.existsSync(pluginPackagePath)) {
                            try {
                                const pluginInfo = JSON.parse(fse.readFileSync(pluginPackagePath))
                                plugins.push({
                                    name: pluginInfo.name,
                                    version: pluginInfo.version,
                                    enabled: true // 默认为启用状态
                                })
                            } catch (e) {
                                console.error(`读取插件${dir}信息失败:`, e)
                            }
                        }
                    }
                })
            }

            // 获取最近部署时间（这里使用一个模拟值，实际应该从部署记录中获取）
            const deployLogPath = path.join(hexo.base_dir, '.deploy_git/.git/logs/HEAD')
            let lastDeployTime = '未知'
            if (fs.existsSync(deployLogPath)) {
                try {
                    const logs = fse.readFileSync(deployLogPath, 'utf-8')
                    const lines = logs.split('\n')
                    if (lines.length > 0) {
                        const lastLine = lines[lines.length - 2] // 最后一行通常是空行，所以取倒数第二行
                        if (lastLine) {
                            const match = lastLine.match(/>\s(\d+)\s/)
                            if (match && match[1]) {
                                const timestamp = parseInt(match[1])
                                lastDeployTime = formatDateTime(new Date(timestamp * 1000))
                            }
                        }
                    }
                } catch (e) {
                    console.error('读取部署日志失败:', e)
                }
            }

            res.done({
                hexoVersion: hexoVersion,
                theme: theme,
                plugins: plugins,
                lastDeployTime: lastDeployTime,
                author: author
            })
        } catch (error) {
            console.error('获取系统信息失败:', error)
            res.send(500, '获取系统信息失败')
        }
    })

    // 获取待办事项列表
    use('dashboard/todos/list', function (req, res) {
        try {
            const todosPath = path.join(hexo.base_dir, 'todos.json')
            let todos = []

            if (fs.existsSync(todosPath)) {
                try {
                    todos = JSON.parse(fse.readFileSync(todosPath))
                } catch (e) {
                    console.error('解析待办事项文件失败:', e)
                }
            }

            res.done(todos)
        } catch (error) {
            console.error('获取待办事项失败:', error)
            res.send(500, '获取待办事项失败')
        }
    })

    // 添加待办事项
    use('dashboard/todos/add', function (req, res, next) {
        if (req.method !== 'POST') return next()

        try {
            if (!req.body || !req.body.content) {
                return res.send(400, '缺少待办事项内容')
            }

            const todosPath = path.join(hexo.base_dir, 'todos.json')
            let todos = []

            if (fs.existsSync(todosPath)) {
                try {
                    todos = JSON.parse(fse.readFileSync(todosPath))
                } catch (e) {
                    console.error('解析待办事项文件失败:', e)
                }
            }

            // 添加新待办事项
            const newTodo = {
                id: Date.now().toString(),
                content: req.body.content,
                completed: false,
                createdAt: formatDateTime(new Date())
            }

            todos.push(newTodo)

            // 保存到文件
            fs.writeFileSync(todosPath, JSON.stringify(todos, null, 2))

            res.done(newTodo)
        } catch (error) {
            console.error('添加待办事项失败:', error)
            res.send(500, '添加待办事项失败')
        }
    })

    // 切换待办事项完成状态
    use('dashboard/todos/toggle/:id', function (req, res, next) {
        if (req.method !== 'PUT') {
            console.log('[TODO TOGGLE] Method not PUT, calling next()'); // 添加日志
            return next();
        }
    
        try {
            const todoId = req.params.id;
            if (!todoId) {
                console.log('[TODO TOGGLE] Missing todoId'); // 添加日志
                return res.send(400, '缺少待办事项 ID');
            }
    
            const todosPath = path.join(hexo.base_dir, 'todos.json');
            let todos = [];
    
            if (fs.existsSync(todosPath)) {
                try {
                    todos = JSON.parse(fse.readFileSync(todosPath));
                } catch (e) {
                    console.error('解析待办事项文件失败:', e);
                    return res.send(500, '处理待办事项文件失败');
                }
            } else {
                 console.log(`[TODO TOGGLE] todos.json not found at: ${todosPath}`); // 添加日志
            }
    
            const todoIndex = todos.findIndex(todo => todo.id === todoId);
    
            if (todoIndex === -1) {
                return res.send(404, '未找到待办事项');
            }
    
            // 切换完成状态
            todos[todoIndex].completed = !todos[todoIndex].completed;
    
            // 保存到文件
            fs.writeFileSync(todosPath, JSON.stringify(todos, null, 2));
    
            res.done(todos[todoIndex]); // 返回更新后的待办事项
        } catch (error) {
            console.error('切换待办事项状态失败:', error);
            res.send(500, '切换待办事项状态失败');
        }
    });

    // 删除待办事项
    use('dashboard/todos/delete/:id', function (req, res, next) {
        if (req.method !== 'DELETE') return next() // 使用 DELETE 方法

        try {
            const todoId = req.params.id
            if (!todoId) {
                return res.send(400, '缺少待办事项 ID')
            }

            const todosPath = path.join(hexo.base_dir, 'todos.json')
            let todos = []

            if (fs.existsSync(todosPath)) {
                try {
                    todos = JSON.parse(fse.readFileSync(todosPath))
                } catch (e) {
                    console.error('解析待办事项文件失败:', e)
                    return res.send(500, '处理待办事项文件失败')
                }
            }

            const initialLength = todos.length
            todos = todos.filter(todo => todo.id !== todoId)

            if (todos.length === initialLength) {
                return res.send(404, '未找到待办事项')
            }

            // 保存到文件
            fs.writeFileSync(todosPath, JSON.stringify(todos, null, 2))

            res.done({ success: true, message: '删除成功' })
        } catch (error) {
            console.error('删除待办事项失败:', error)
            res.send(500, '删除待办事项失败')
        }
    })


    // 辅助函数：格式化日期时间
    function formatDateTime(dateString) {
        const date = new Date(dateString)

        const year = date.getFullYear()
        const month = String(date.getMonth() + 1).padStart(2, '0')
        const day = String(date.getDate()).padStart(2, '0')
        const hours = String(date.getHours()).padStart(2, '0')
        const minutes = String(date.getMinutes()).padStart(2, '0')
        const seconds = String(date.getSeconds()).padStart(2, '0')

        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`
    }

    // 获取网站访问统计数据
    use('dashboard/visit/stats', async function (req, res) {
        try {
            // 获取主题配置
            const themeConfig = hexo.theme.config || {};
            const siteUrl = hexo.config.url || '';

            // 检查是否启用了busuanzi统计
            const busuanziEnabled = themeConfig.busuanzi

            if (busuanziEnabled) {
                try {
                    // 尝试从博客首页获取busuanzi统计数据
                    const response = await axios.get(siteUrl, { timeout: 5000 });
                    const html = response.data;

                    // 修改正则表达式以匹配新的HTML结构
                    const siteUvMatch = html.match(/id="busuanzi_value_site_uv"[^>]*>([\d,]+)/);
                    const sitePvMatch = html.match(/id="busuanzi_value_site_pv"[^>]*>([\d,]+)/);

                    // 如果匹配失败，尝试使用备用正则表达式
                    let siteUv = 0;
                    let sitePv = 0;
                    
                    if (siteUvMatch && siteUvMatch[1]) {
                        siteUv = parseInt(siteUvMatch[1].replace(/,/g, ''));
                    } else {
                        // 备用正则表达式
                        const altUvMatch = html.match(/id="busuanzi_value_site_uv"[^>]*>([^<]+)/);
                        if (altUvMatch && altUvMatch[1] && !isNaN(parseInt(altUvMatch[1].replace(/,/g, '')))) {
                            siteUv = parseInt(altUvMatch[1].replace(/,/g, ''));
                        }
                    }
                    
                    if (sitePvMatch && sitePvMatch[1]) {
                        sitePv = parseInt(sitePvMatch[1].replace(/,/g, ''));
                    } else {
                        // 备用正则表达式
                        const altPvMatch = html.match(/id="busuanzi_value_site_pv"[^>]*>([^<]+)/);
                        if (altPvMatch && altPvMatch[1] && !isNaN(parseInt(altPvMatch[1].replace(/,/g, '')))) {
                            sitePv = parseInt(altPvMatch[1].replace(/,/g, ''));
                        }
                    }

                    // 获取历史访问数据（如果有存储的话）
                    const visitStatsPath = path.join(hexo.base_dir, 'visit_stats.json');
                    let visitHistory = [];

                    if (fs.existsSync(visitStatsPath)) {
                        try {
                            visitHistory = JSON.parse(fse.readFileSync(visitStatsPath));
                        } catch (e) {
                            console.error('解析访问统计历史数据失败:', e);
                        }
                    }

                    // 返回数据
                    res.done({
                        success: true,
                        busuanziEnabled: true,
                        currentStats: {
                            siteUv: siteUv,
                            sitePv: sitePv
                        },
                        visitHistory: visitHistory
                    });
                } catch (error) {
                    // 如果获取失败，返回错误信息
                    console.error('获取busuanzi统计数据失败:', error);
                    res.done({
                        success: false,
                        busuanziEnabled: true,
                        error: '获取统计数据失败',
                        visitHistory: []
                    });
                }
            } else {
                // 如果未启用busuanzi，返回相应信息
                res.done({
                    success: false,
                    busuanziEnabled: false,
                    message: '未启用busuanzi统计',
                    visitHistory: []
                });
            }
        } catch (error) {
            console.error('获取访问统计失败:', error);
            res.send(500, '获取访问统计失败');
        }
    });

    // 获取最近6个月的文章发布统计
    use('dashboard/posts/monthly-stats', function (req, res) {
        try {
            const posts = hexo.model('Post').toArray();
            const publishedPosts = posts.filter(post => !(post.source && post.source.indexOf('_draft') === 0));
            
            // 获取最近6个月的日期范围
            const today = new Date();
            const months = [];
            for (let i = 5; i >= 0; i--) {
                const month = new Date(today.getFullYear(), today.getMonth() - i, 1);
                const monthStr = `${month.getFullYear()}-${String(month.getMonth() + 1).padStart(2, '0')}`;
                months.push(monthStr);
            }
            
            // 统计每月发布的文章数量
            const monthlyStats = months.map(month => {
                const count = publishedPosts.filter(post => {
                    const postDate = new Date(post.date);
                    const postMonth = `${postDate.getFullYear()}-${String(postDate.getMonth() + 1).padStart(2, '0')}`;
                    return postMonth === month;
                }).length;
                
                return {
                    month: month,
                    count: count
                };
            });
            
            res.done(monthlyStats);
        } catch (error) {
            console.error('获取月度文章统计失败:', error);
            res.send(500, '获取月度文章统计失败');
        }
    });

    // 获取最近一月新增文章数
    use('dashboard/posts/monthly-new', function (req, res) { 
        try { 
            const posts = hexo.model('Post').toArray() 
            const now = new Date() 
            // 本月1号
            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1)
            
            // 计算本月新增的文章数量 
            const newPostsCount = posts.filter(post => { 
                const postDate = new Date(post.date) 
                return postDate >= monthStart && postDate <= now 
            }).length 
    
            res.done({ 
                count: newPostsCount 
            }) 
        } catch (error) { 
            console.error('获取本月新增文章数失败:', error) 
            res.send(500, '获取本月新增文章数失败') 
        } 
    })
}const Datastore = require('@seald-io/nedb');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

class DatabaseManager {
  constructor() {
    this.isInitialized = false;
    this.initPromise = null;
    this.databases = {
      userDb: null,
      settingsDb: null,
      deployStatusDb: null
    };
    this.hexoInstance = null;
  }

  async initialize(hexo) {
    // 如果已经初始化，直接返回数据库实例
    if (this.isInitialized) {
      console.log('[Database Manager]: 数据库已初始化，返回现有实例');
      return this.databases;
    }

    // 如果正在初始化，等待初始化完成
    if (this.initPromise) {
      console.log('[Database Manager]: 数据库正在初始化，等待完成...');
      return await this.initPromise;
    }

    // 开始初始化
    console.log('[Database Manager]: 开始初始化数据库...');
    this.hexoInstance = hexo;
    this.initPromise = this._performInitialization();
    
    try {
      const result = await this.initPromise;
      this.isInitialized = true;
      console.log('[Database Manager]: 数据库初始化完成');
      return result;
    } catch (error) {
      // 初始化失败，重置状态
      this.initPromise = null;
      throw error;
    }
  }

  async _performInitialization() {
    const hexo = this.hexoInstance;
    
    // 确保 data 目录存在
    const dataDir = path.join(hexo.base_dir, 'data');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }

    // 清理损坏的数据库文件
    this._cleanupCorruptedDbFiles(dataDir);

    // 并行创建所有数据库
    console.log('[Database Manager]: 创建数据库实例...');
    
    const [userDb, settingsDb, deployStatusDb] = await Promise.all([
      this._createDatabase(dataDir, 'users.db'),
      this._createDatabase(dataDir, 'settings.db'),
      this._createDatabase(dataDir, 'deploy_status.db')
    ]);

    // 保存数据库实例
    this.databases.userDb = userDb;
    this.databases.settingsDb = settingsDb;
    this.databases.deployStatusDb = deployStatusDb;

    console.log('[Database Manager]: 所有数据库实例创建完成');

    // 初始化数据库内容
    await this._initializeDeployStatus(deployStatusDb);
    await this._initializeUserAndSettings(userDb, settingsDb, hexo);

    return this.databases;
  }

  _cleanupCorruptedDbFiles(dataDir) {
    const dbFiles = ['users.db', 'settings.db', 'deploy_status.db'];
    
    dbFiles.forEach(dbFile => {
      const filePath = path.join(dataDir, dbFile);
      
      try {
        if (fs.existsSync(filePath)) {
          const stats = fs.statSync(filePath);
          // 如果文件大小为0字节，则删除它
          if (stats.size === 0) {
            console.log(`[Database Manager]: 删除损坏的数据库文件 ${dbFile}`);
            fs.unlinkSync(filePath);
          }
        }
        
        // 清理临时文件（以 ~ 结尾）
        const tempFilePath = filePath + '~';
        if (fs.existsSync(tempFilePath)) {
          console.log(`[Database Manager]: 清理临时文件 ${dbFile}~`);
          fs.unlinkSync(tempFilePath);
        }
      } catch (error) {
        console.warn(`[Database Manager]: 清理文件 ${dbFile} 时出错:`, error.message);
      }
    });
  }

  _createDatabase(dataDir, filename, retryCount = 3, delay = 1000) {
    return new Promise((resolve, reject) => {
      let attempts = 0;
      
      const attemptLoad = () => {
        attempts++;
        console.log(`[Database Manager]: 创建数据库 ${filename} (尝试 ${attempts}/${retryCount})`);
        
        const db = new Datastore({
          filename: path.join(dataDir, filename),
          autoload: true,
          onload: function (error) {
            if (error) {
              console.error(`[Database Manager]: 数据库 ${filename} 创建失败 (尝试 ${attempts}):`, error.message);
              
              if (attempts < retryCount) {
                console.log(`[Database Manager]: ${delay}ms 后重试创建数据库 ${filename}...`);
                setTimeout(attemptLoad, delay);
              } else {
                console.error(`[Database Manager]: 数据库 ${filename} 创建失败，达到最大重试次数`);
                reject(new Error(`数据库 ${filename} 创建失败: ${error.message}`));
              }
            } else {
              console.log(`[Database Manager]: 数据库 ${filename} 创建成功`);
              resolve(db);
            }
          }
        });
      };
      
      attemptLoad();
    });
  }

  async _initializeDeployStatus(deployStatusDb) {
    return new Promise((resolve, reject) => {
      deployStatusDb.findOne({ type: 'status' }, (err, doc) => {
        if (err) {
          reject(err);
          return;
        }

        if (!doc) {
          deployStatusDb.insert({
            type: 'status',
            isDeploying: false,
            progress: 0,
            stage: 'idle',
            lastDeployTime: '',
            logs: [],
            error: null
          }, (insertErr) => {
            if (insertErr) {
              reject(insertErr);
            } else {
              console.log('[Database Manager]: 部署状态数据库初始化完成');
              resolve();
            }
          });
        } else if (doc.isDeploying) {
          // 如果服务重启时发现有未完成的部署，自动重置状态
          deployStatusDb.update(
            { type: 'status' },
            {
              $set: {
                isDeploying: false,
                stage: 'failed',
                error: 'deploy.interruption.cause.by.service.restart',
                logs: [...(doc.logs || []), 'deploy.interruption.cause.by.service.restart.status.reset']
              }
            },
            {},
            (updateErr) => {
              if (updateErr) {
                reject(updateErr);
              } else {
                console.log('[Database Manager]: 重置未完成的部署状态');
                resolve();
              }
            }
          );
        } else {
          console.log('[Database Manager]: 部署状态数据库已存在');
          resolve();
        }
      });
    });
  }

  async _initializeUserAndSettings(userDb, settingsDb, hexo) {
    try {
      // 检查用户数据库是否为空
      const userCount = await new Promise((resolve, reject) => {
        userDb.count({}, (err, count) => {
          if (err) reject(err);
          else resolve(count);
        });
      });

      // 如果数据库为空且配置中有用户名和密码，则导入
      if (userCount === 0 && hexo.config.hexo_pro && hexo.config.hexo_pro.username && hexo.config.hexo_pro.password) {
        const defaultUser = {
          username: hexo.config.hexo_pro.username,
          password: hexo.config.hexo_pro.password,
          avatar: hexo.config.avatar ? hexo.config.avatar : '',
          createdAt: new Date(),
          updatedAt: new Date()
        };

        await new Promise((resolve, reject) => {
          userDb.insert(defaultUser, (err, doc) => {
            if (err) reject(err);
            else resolve(doc);
          });
        });

        console.log('[Database Manager]: 从配置文件导入初始用户');
        
        // 检查系统设置数据库是否为空
        const settingsCount = await new Promise((resolve, reject) => {
          settingsDb.count({ type: 'system' }, (err, count) => {
            if (err) reject(err);
            else resolve(count);
          });
        });
        
        // 如果设置为空，则导入或生成 JWT secret
        if (settingsCount === 0) {
          const jwtSecret = hexo.config.hexo_pro && hexo.config.hexo_pro.secret 
            ? hexo.config.hexo_pro.secret 
            : crypto.randomBytes(32).toString('hex');
          
          await new Promise((resolve, reject) => {
            settingsDb.insert({
              type: 'system',
              jwtSecret: jwtSecret,
              createdAt: new Date()
            }, (err, doc) => {
              if (err) reject(err);
              else resolve(doc);
            });
          });
          
          if (hexo.config.hexo_pro && hexo.config.hexo_pro.secret) {
            console.log('[Database Manager]: 从配置文件导入 JWT 密钥');
          } else {
            console.log('[Database Manager]: 自动生成 JWT 密钥');
          }
        }

        global.actualNeedLogin = true;
      }
    } catch (error) {
      console.error('[Database Manager]: 初始化用户和设置失败', error);
      throw error;
    }
  }

  // 获取数据库实例（确保已初始化）
  getDatabases() {
    if (!this.isInitialized) {
      throw new Error('数据库尚未初始化，请先调用 initialize()');
    }
    return this.databases;
  }

  // 检查是否已初始化
  isReady() {
    return this.isInitialized;
  }

  // 重置状态（用于测试或重新初始化）
  reset() {
    console.log('[Database Manager]: 重置数据库管理器状态');
    this.isInitialized = false;
    this.initPromise = null;
    this.databases = {
      userDb: null,
      settingsDb: null,
      deployStatusDb: null
    };
    this.hexoInstance = null;
  }
}

// 创建全局单例实例
const databaseManager = new DatabaseManager();

module.exports = databaseManager; const Datastore = require('@seald-io/nedb');
const path = require('path');
const fs = require('fs');
// 添加 crypto 模块用于生成随机密钥
const crypto = require('crypto');

module.exports = function(hexo) {
  // 确保 data 目录存在
  const dataDir = path.join(hexo.base_dir, 'data');
  if (!fs.existsSync(dataDir)) {
    fs.mkdirSync(dataDir, { recursive: true });
  }

  // 检查并清理损坏的数据库文件
  const cleanupCorruptedDbFiles = () => {
    const dbFiles = ['users.db', 'settings.db', 'deploy_status.db'];
    
    dbFiles.forEach(dbFile => {
      const filePath = path.join(dataDir, dbFile);
      if (fs.existsSync(filePath)) {
        const stats = fs.statSync(filePath);
        // 如果文件大小为0字节，则删除它
        if (stats.size === 0) {
          console.log(`[Hexo Pro]: 检测到损坏的数据库文件 ${dbFile}，正在删除...`);
          fs.unlinkSync(filePath);
        }
      }
      
      // 同时检查临时文件（以 ~ 结尾）
      const tempFilePath = filePath + '~';
      if (fs.existsSync(tempFilePath)) {
        console.log(`[Hexo Pro]: 清理临时数据库文件 ${dbFile}~`);
        fs.unlinkSync(tempFilePath);
      }
    });
  };

  // 创建带重试的数据库加载函数
  const createDatabase = (filename, retryCount = 3, delay = 1000) => {
    return new Promise((resolve, reject) => {
      let attempts = 0;
      
      const attemptLoad = () => {
        attempts++;
        console.log(`[Hexo Pro]: 尝试加载数据库 ${filename} (第 ${attempts}/${retryCount} 次)`);
        
        const db = new Datastore({
          filename: path.join(dataDir, filename),
          autoload: true,
          onload: function (error) {
            if (error) {
              console.error(`[Hexo Pro]: 数据库 ${filename} 加载失败 (第 ${attempts} 次尝试):`, error);
              
              if (attempts < retryCount) {
                console.log(`[Hexo Pro]: ${delay}ms 后重试加载数据库 ${filename}...`);
                setTimeout(attemptLoad, delay);
              } else {
                console.error(`[Hexo Pro]: 数据库 ${filename} 加载失败，已达到最大重试次数`);
                reject(new Error(`数据库 ${filename} 加载失败: ${error.message}`));
              }
            } else {
              console.log(`[Hexo Pro]: 数据库 ${filename} 加载成功`);
              resolve(db);
            }
          }
        });
      };
      
      attemptLoad();
    });
  };

  // 生成随机 JWT 密钥的函数
  const generateJwtSecret = () => {
    return crypto.randomBytes(32).toString('hex');
  };

  // 初始化数据库的主函数 - 返回 Promise
  const initializeDatabase = async () => {
    try {
      // 执行清理
      cleanupCorruptedDbFiles();

      // 并行创建所有数据库，确保都加载成功
      console.log('[Hexo Pro]: 开始初始化所有数据库...');
      
      const [userDb, settingsDb, deployStatusDb] = await Promise.all([
        createDatabase('users.db'),
        createDatabase('settings.db'),
        createDatabase('deploy_status.db')
      ]);

      console.log('[Hexo Pro]: 所有数据库加载完成');

      // 初始化部署状态数据库
      await initializeDeployStatus(deployStatusDb);

      // 初始化用户和设置数据库
      await initializeUserAndSettings(userDb, settingsDb, hexo);

      return {
        userDb,
        settingsDb,
        deployStatusDb
      };
    } catch (error) {
      console.error('[Hexo Pro]: 数据库初始化失败:', error);
      throw error;
    }
  };

  // 初始化部署状态数据库
  const initializeDeployStatus = async (deployStatusDb) => {
    return new Promise((resolve, reject) => {
      deployStatusDb.findOne({ type: 'status' }, (err, doc) => {
        if (err) {
          reject(err);
          return;
        }

        if (!doc) {
          deployStatusDb.insert({
            type: 'status',
            isDeploying: false,
            progress: 0,
            stage: 'idle',
            lastDeployTime: '',
            logs: [],
            error: null
          }, (insertErr) => {
            if (insertErr) {
              reject(insertErr);
            } else {
              console.log('[Hexo Pro]: 部署状态数据库初始化完成');
              resolve();
            }
          });
        } else if (doc.isDeploying) {
          // 如果服务重启时发现有未完成的部署，自动重置状态
          deployStatusDb.update(
            { type: 'status' },
            {
              $set: {
                isDeploying: false,
                stage: 'failed',
                error: 'deploy.interruption.cause.by.service.restart',
                logs: [...(doc.logs || []), 'deploy.interruption.cause.by.service.restart.status.reset']
              }
            },
            {},
            (updateErr) => {
              if (updateErr) {
                reject(updateErr);
              } else {
                console.log('[Hexo Pro]: 检测到未完成的部署，已重置状态');
                resolve();
              }
            }
          );
        } else {
          console.log('[Hexo Pro]: 部署状态数据库已存在');
          resolve();
        }
      });
    });
  };

  // 初始化用户和设置数据库，从 _config.yml 导入初始用户（仅在数据库为空时）
  const initializeUserAndSettings = async (userDb, settingsDb, hexo) => {
    try {
      // 检查用户数据库是否为空
      const userCount = await new Promise((resolve, reject) => {
        userDb.count({}, (err, count) => {
          if (err) reject(err);
          else resolve(count);
        });
      });

      // 如果数据库为空且配置中有用户名和密码，则导入
      // 这是为了向后兼容，仅在首次运行时从配置导入用户
      if (userCount === 0 && hexo.config.hexo_pro && hexo.config.hexo_pro.username && hexo.config.hexo_pro.password) {
        const defaultUser = {
          username: hexo.config.hexo_pro.username,
          password: hexo.config.hexo_pro.password,
          avatar:   hexo.config.avatar ? hexo.config.avatar :  '',
          createdAt: new Date(),
          updatedAt: new Date()
        };

        await new Promise((resolve, reject) => {
          userDb.insert(defaultUser, (err, doc) => {
            if (err) reject(err);
            else resolve(doc);
          });
        });

        console.log('[Hexo Pro]: 已从配置文件导入初始用户（仅首次运行）');
        
        // 检查系统设置数据库是否为空
        const settingsCount = await new Promise((resolve, reject) => {
          settingsDb.count({ type: 'system' }, (err, count) => {
            if (err) reject(err);
            else resolve(count);
          });
        });
        
        // 如果设置为空，则导入或生成 JWT secret
        if (settingsCount === 0) {
          // 如果配置中有 JWT secret 则使用，否则生成一个新的
          const jwtSecret = hexo.config.hexo_pro && hexo.config.hexo_pro.secret 
            ? hexo.config.hexo_pro.secret 
            : generateJwtSecret();
          
          await new Promise((resolve, reject) => {
            settingsDb.insert({
              type: 'system',
              jwtSecret: jwtSecret,
              createdAt: new Date()
            }, (err, doc) => {
              if (err) reject(err);
              else resolve(doc);
            });
          });
          
          if (hexo.config.hexo_pro && hexo.config.hexo_pro.secret) {
            console.log('[Hexo Pro]: 已从配置文件导入 JWT 密钥');
          } else {
            console.log('[Hexo Pro]: 已自动生成 JWT 密钥');
          }
        }

        global.actualNeedLogin = true;
      }
    } catch (error) {
      console.error('[Hexo Pro]: 初始化用户和设置数据库失败', error);
      throw error;
    }
  };

  // 返回初始化函数的 Promise
  return initializeDatabase();
};// 导入 Hexo 模块
const Hexo = require('hexo');
const path = require('path');
const chokidar = require('chokidar');
const browserSync = require('browser-sync').create();

// 创建 Hexo 实例
async function startHexoServer() {
    const hexo = new Hexo(path.resolve(__dirname, '/Users/warms/Workspace/code/node_project/blog'), { cache: false });

    // 初始化 Hexo
    await hexo.init().then(function () {
        return hexo.load();
    }).then(function () {
        console.log('Hexo 初始化完成，开始调试');
        console.log('Hexo 版本:', hexo.version);
    }).catch(function (err) {
        console.error('Hexo 初始化失败:', err);
    });

    // 启动 Hexo 服务器
    const server = await hexo.call('server', {
        port: 8001,
        ip: '127.0.0.1'  // 限制只监听本地环回地址
    });

    console.log('Hexo server is running at http://localhost:7001');

    // 启动 browser-sync 进行自动刷新
    browserSync.init({
        proxy: 'http://localhost:8001',
        files: ['public/**/*', 'themes/butterfly/**/*'],
        notify: false,
        open: 'external', // 尝试用 'external'
        ui: false,
        port: 8081,
    });

    // 使用 chokidar 监听 butterfly 主题目录的变化
    const themePath = path.join(hexo.base_dir, 'themes', 'butterfly'); // butterfly 主题目录

    // 创建 watcher 监听主题目录
    const watcher = chokidar.watch(themePath, {
        ignored: /^\./,  // 忽略隐藏文件
        persistent: true,
    });

    watcher.on('change', async (filePath) => {
        console.log(`文件变动: ${filePath}`);
        // 当文件变化时重新生成静态文件
        await hexo.call('generate', {});
        console.log('Hexo 页面已重新生成');

        // 告诉 browser-sync 重新加载浏览器
        browserSync.reload();
    });

    // 监听结束后输出
    watcher.on('error', (error) => console.error('监听错误:', error));
}

// 启动 Hexo 服务器
startHexoServer().catch(err => {
    console.error(err);
});
const path = require('path');
const fs = require('hexo-fs');
const fse = require('fs-extra');
const { exec, spawn } = require('child_process');
const utils = require('./utils');
const yaml = require('js-yaml');

module.exports = function (app, hexo, use, db) {
    // 使用传入的统一数据库实例，而不是创建自己的
    if (!db || !db.deployStatusDb) {
        throw new Error('[Hexo Pro]: 部署API需要数据库实例');
    }

    const deployStatusDb = db.deployStatusDb;

    // 获取部署配置
    use('deploy/config', function (req, res) {
        try {
            const configPath = path.join(hexo.base_dir, 'deploy_config.json');
            let config = {
                repository: '',
                branch: 'main',
                message: 'Site updated: {{ now("YYYY-MM-DD HH:mm:ss") }}',
                token: '',
                lastDeployTime: ''
            };

            if (fs.existsSync(configPath)) {
                try {
                    const savedConfig = JSON.parse(fs.readFileSync(configPath));
                    // 不返回敏感信息如 token
                    config = {
                        ...savedConfig,
                        token: savedConfig.token ? '******' : ''
                    };
                } catch (e) {
                    console.error('解析部署配置文件失败:', e);
                }
            }

            res.done(config);
        } catch (error) {
            console.error('获取部署配置失败:', error);
            res.send(500, '获取部署配置失败');
        }
    });

    // 保存部署配置
    use('deploy/save-config', function (req, res, next) {
        if (req.method !== 'POST') return next();

        try {
            if (!req.body) {
                return res.send(400, '缺少配置信息');
            }

            const configPath = path.join(hexo.base_dir, 'deploy_config.json');
            let existingConfig = {};

            if (fs.existsSync(configPath)) {
                try {
                    existingConfig = JSON.parse(fs.readFileSync(configPath));
                } catch (e) {
                    console.error('解析现有部署配置文件失败:', e);
                }
            }

            // 合并配置，保留现有 token（如果新配置中没有提供）
            const newConfig = {
                ...existingConfig,
                ...req.body,
                // 如果新配置中的 token 是占位符，则保留原来的 token
                token: req.body.token === '******' ? existingConfig.token : req.body.token
            };

            // 保存到文件
            fs.writeFileSync(configPath, JSON.stringify(newConfig, null, 2));

            // 更新 _config.yml 文件中的 deploy 配置
            updateHexoConfig(hexo.base_dir, newConfig);

            // 返回配置（隐藏 token）
            const safeConfig = {
                ...newConfig,
                token: newConfig.token ? '******' : ''
            };

            res.done(safeConfig);
        } catch (error) {
            console.error('保存部署配置失败:', error);
            res.send(500, '保存部署配置失败');
        }
    });

    // 执行部署 - 改为异步方式
    use('deploy/execute', function (req, res, next) {
        if (req.method !== 'POST') return next();

        try {
            // 检查是否正在部署
            deployStatusDb.findOne({ type: 'status' }, (err, status) => {
                if (err) {
                    return res.send(500, '获取部署状态失败');
                }

                if (status && status.isDeploying) {
                    return res.send(400, '部署正在进行中，请等待完成');
                }

                const configPath = path.join(hexo.base_dir, 'deploy_config.json');
                if (!fs.existsSync(configPath)) {
                    return res.send(400, '部署配置不存在，请先保存配置');
                }

                let config;
                try {
                    config = JSON.parse(fs.readFileSync(configPath));
                } catch (e) {
                    console.error('解析部署配置文件失败:', e);
                    return res.send(500, '解析部署配置失败');
                }

                if (!config.repository) {
                    return res.send(400, '缺少仓库地址');
                }

                // 获取跳过生成的设置
                const skipGenerate = req.body && req.body.skipGenerate === true;

                // 更新部署状态为进行中
                deployStatusDb.update(
                    { type: 'status' },
                    {
                        $set: {
                            isDeploying: true,
                            progress: 0,
                            stage: 'started',
                            logs: ['deploy.started'],
                            error: null
                        }
                    },
                    {},
                    (err) => {
                        if (err) {
                            console.error('更新部署状态失败:', err);
                            return res.send(500, '更新部署状态失败');
                        }

                        // 立即返回响应，不等待部署完成
                        res.done({
                            success: true,
                            message: '部署已开始，请通过状态 API 查询进度',
                            isDeploying: true
                        });

                        // 异步执行部署
                        executeDeployAsync(hexo.base_dir, deployStatusDb, config, skipGenerate);
                    }
                );
            });
        } catch (error) {
            console.error('执行部署失败:', error);
            res.send(500, `执行部署失败: ${error.message}`);
        }
    });

    // 检查部署状态 - 增强版
    use('deploy/status', function (req, res) {
        try {
            deployStatusDb.findOne({ type: 'status' }, (err, status) => {
                if (err) {
                    return res.send(500, '获取部署状态失败');
                }

                if (!status) {
                    return res.done({
                        isDeploying: false,
                        progress: 0,
                        stage: 'idle',
                        lastDeployTime: '未知',
                        logs: [],
                        hasDeployGit: fs.existsSync(path.join(hexo.base_dir, '.deploy_git'))
                    });
                }

                // 检查 .deploy_git 目录是否存在
                const hasDeployGit = fs.existsSync(path.join(hexo.base_dir, '.deploy_git'));

                res.done({
                    ...status,
                    hasDeployGit
                });
            });
        } catch (error) {
            console.error('获取部署状态失败:', error);
            res.send(500, '获取部署状态失败');
        }
    });

    // 辅助函数：格式化日期时间
    function formatDateTime(dateString) {
        const date = new Date(dateString);

        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');

        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    // 辅助函数：更新 Hexo 配置文件中的 deploy 部分
    function updateHexoConfig(baseDir, deployConfig) {
        try {
            const hexoConfigPath = path.join(baseDir, '_config.yml');

            // 读取现有配置
            let hexoConfigContent = fse.readFileSync(hexoConfigPath, 'utf-8');
            let hexoConfig;

            try {
                hexoConfig = yaml.load(hexoConfigContent);
            } catch (e) {
                console.error('解析 Hexo 配置文件失败:', e);
                throw new Error('解析 Hexo 配置文件失败');
            }

            // 构建新的 deploy 配置
            const repoUrl = deployConfig.token
                ? `https://${deployConfig.token}@github.com/${deployConfig.repository}.git`
                : `https://github.com/${deployConfig.repository}.git`;

            // 更新 deploy 配置
            hexoConfig.deploy = {
                type: 'git',
                repo: repoUrl,
                branch: deployConfig.branch,
                message: deployConfig.message
            };

            // 将配置写回文件
            const newConfigContent = yaml.dump(hexoConfig);
            fs.writeFileSync(hexoConfigPath, newConfigContent, 'utf-8');

            console.log('已更新 _config.yml 中的部署配置');
        } catch (error) {
            console.error('更新 Hexo 配置文件失败:', error);
            throw error;
        }
    }

    // 辅助函数：处理提交消息模板
    function processCommitMessage(message) {
        // 替换 {{ now("YYYY-MM-DD HH:mm:ss") }} 格式
        return message.replace(/\{\{\s*now\(["']([^"']+)["']\)\s*\}\}/g, (match, format) => {
            const now = new Date();
            // 简单的日期格式化
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            
            return format
                .replace('YYYY', year)
                .replace('MM', month)
                .replace('DD', day)
                .replace('HH', hours)
                .replace('mm', minutes)
                .replace('ss', seconds);
        });
    }

    // 辅助函数：异步执行部署过程
    function executeDeployAsync(baseDir, deployStatusDb, config, skipGenerate) {
        const updateStatus = (update) => {
            return new Promise((resolve, reject) => {
                deployStatusDb.update(
                    { type: 'status' },
                    { $set: update },
                    {},
                    (err) => {
                        if (err) {
                            console.error('更新部署状态失败:', err);
                            reject(err);
                        } else {
                            resolve();
                        }
                    }
                );
            });
        };

        const addLog = (message) => {
            console.log(message);
            deployStatusDb.findOne({ type: 'status' }, (err, status) => {
                if (!err && status) {
                    const logs = [...status.logs, message];
                    deployStatusDb.update(
                        { type: 'status' },
                        { $set: { logs: logs } },
                        {}
                    );
                }
            });
        };

        const runCommand = (command, args, options) => {
            return new Promise((resolve, reject) => {
                let finalCommand = command;
                let finalArgs = args;
                let mergedOptions = { 
                    ...options,
                    shell: true,
                    windowsVerbatimArguments: false
                };

                // 对于 git commit 命令，使用特殊处理避免 shell 解析问题
                if (command === 'git' && args[0] === 'commit' && args.includes('-m')) {
                    const messageIndex = args.indexOf('-m') + 1;
                    if (messageIndex < args.length) {
                        // 创建新的参数数组，确保提交消息被正确引用
                        finalArgs = [...args];
                        finalArgs[messageIndex] = `"${args[messageIndex]}"`;
                    }
                }

                addLog(`run command: ${finalCommand} ${finalArgs.join(' ')}`);
                const proc = spawn(finalCommand, finalArgs, mergedOptions);

                proc.stdout.on('data', (data) => {
                    addLog(data.toString().trim());
                });

                proc.stderr.on('data', (data) => {
                    const message = data.toString().trim();
                    if (message.includes('Waiting for the debugger to disconnect')) {
                        addLog(message);
                    } else {
                        addLog(`error: ${message}`);
                    }
                });

                proc.on('close', (code) => {
                    if (code === 0) {
                        resolve();
                    } else {
                        reject(new Error(`命令执行失败，退出码: ${code}`));
                    }
                });

                proc.on('error', (err) => {
                    addLog(`Process error: ${err.message}`);
                    reject(err);
                });
            });
        };

        // 自定义 Git 部署函数
        const customGitDeploy = async (baseDir, config, skipGenerate = false) => {
            const deployDir = path.join(baseDir, '.deploy_git');
            const publicDir = path.join(baseDir, 'public');
            
            // 构建仓库URL
            const repoUrl = config.token
                ? `https://${config.token}@github.com/${config.repository}.git`
                : `https://github.com/${config.repository}.git`;

            // 处理提交消息
            const commitMessage = processCommitMessage(config.message || 'Site updated');

            addLog('deploy.git.preparing');

            if (!skipGenerate) {
                // 标准模式：检查 public 目录是否存在
                if (!fs.existsSync(publicDir)) {
                    throw new Error('public 目录不存在，请先运行 hexo generate');
                }
            }

            // 初始化或更新 .deploy_git 目录
            if (skipGenerate) {
                // 跳过生成模式：重新初始化部署目录以避免历史记录中的敏感信息
                if (fs.existsSync(deployDir)) {
                    addLog('deploy.git.cleaning.old.deploy.dir');
                    await fse.remove(deployDir);
                }
                
                addLog('deploy.git.init.fresh.repo');
                await runCommand('git', ['clone', '--depth', '1', repoUrl, '.deploy_git'], { cwd: baseDir });
                
                // 切换到指定分支
                try {
                    await runCommand('git', ['checkout', config.branch || 'main'], { cwd: deployDir });
                } catch (error) {
                    // 如果分支不存在，创建新分支
                    addLog(`deploy.git.creating.branch: ${config.branch || 'main'}`);
                    await runCommand('git', ['checkout', '-b', config.branch || 'main'], { cwd: deployDir });
                }
            } else {
                // 标准模式：正常的git操作
                if (!fs.existsSync(deployDir)) {
                    addLog('deploy.git.cloning');
                    await runCommand('git', ['clone', repoUrl, '.deploy_git'], { cwd: baseDir });
                } else {
                    addLog('deploy.git.updating');
                    
                    // 检查并设置 origin remote
                    try {
                        // 检查 origin remote 是否存在
                        await runCommand('git', ['remote', 'get-url', 'origin'], { cwd: deployDir });
                    } catch (error) {
                        // origin 不存在，添加它
                        addLog('deploy.git.adding.origin');
                        await runCommand('git', ['remote', 'add', 'origin', repoUrl], { cwd: deployDir });
                    }
                    
                    // 确保 origin URL 是正确的
                    try {
                        await runCommand('git', ['remote', 'set-url', 'origin', repoUrl], { cwd: deployDir });
                    } catch (error) {
                        addLog('deploy.git.remote.set.url.failed');
                    }
                    
                    // 切换到指定分支
                    try {
                        await runCommand('git', ['checkout', config.branch || 'main'], { cwd: deployDir });
                    } catch (error) {
                        // 如果分支不存在，创建新分支
                        addLog(`deploy.git.creating.branch: ${config.branch || 'main'}`);
                        await runCommand('git', ['checkout', '-b', config.branch || 'main'], { cwd: deployDir });
                    }
                    
                    // 拉取最新更改
                    try {
                        await runCommand('git', ['pull', 'origin', config.branch || 'main'], { cwd: deployDir });
                    } catch (error) {
                        addLog('deploy.git.pull.failed.continuing');
                    }
                }
            }

            addLog('deploy.git.copying.files');
            
            // 清空 deploy 目录（除了 .git）
            const files = await fse.readdir(deployDir);
            for (const file of files) {
                if (file !== '.git') {
                    await fse.remove(path.join(deployDir, file));
                }
            }

            if (skipGenerate) {
                // 跳过生成模式：复制源代码文件到 deploy 目录
                const filesToCopy = [
                    'source',
                    'themes',
                    'package.json',
                    'scaffolds'
                ];
                
                for (const item of filesToCopy) {
                    const sourcePath = path.join(baseDir, item);
                    const destPath = path.join(deployDir, item);
                    
                    if (fs.existsSync(sourcePath)) {
                        await fse.copy(sourcePath, destPath, {
                            filter: (src, dest) => {
                                // 不复制 .git 目录和 node_modules
                                return !src.includes('.git') && !src.includes('node_modules');
                            }
                        });
                    }
                }
                
                // 特殊处理 _config.yml，移除敏感信息
                const configPath = path.join(baseDir, '_config.yml');
                const deployConfigPath = path.join(deployDir, '_config.yml');
                
                if (fs.existsSync(configPath)) {
                    try {
                        // 读取原始配置
                        const configContent = fse.readFileSync(configPath, 'utf-8');
                        let configObj = yaml.load(configContent);
                        
                        // 清理 deploy 配置中的敏感信息
                        if (configObj.deploy) {
                            if (configObj.deploy.repo && typeof configObj.deploy.repo === 'string') {
                                // 移除 repo URL 中的 token
                                configObj.deploy.repo = configObj.deploy.repo.replace(/https:\/\/[^@]+@github\.com\//, 'https://github.com/');
                            }
                        }
                        
                        // 写入清理后的配置
                        const cleanConfigContent = yaml.dump(configObj);
                        fs.writeFileSync(deployConfigPath, cleanConfigContent, 'utf-8');
                        
                        addLog('deploy.git.config.cleaned');
                    } catch (error) {
                        console.error('处理 _config.yml 失败:', error);
                        // 如果处理失败，直接复制原文件（可能会触发 GitHub 保护）
                        await fse.copy(configPath, deployConfigPath);
                    }
                }
                
                // 复制其他可能存在的配置文件
                const optionalFiles = ['_config.landscape.yml', '_config.next.yml', 'yarn.lock', 'package-lock.json'];
                for (const file of optionalFiles) {
                    const sourcePath = path.join(baseDir, file);
                    const destPath = path.join(deployDir, file);
                    
                    if (fs.existsSync(sourcePath)) {
                        await fse.copy(sourcePath, destPath);
                    }
                }
            } else {
                // 标准模式：复制 public 目录内容到 deploy 目录
                await fse.copy(publicDir, deployDir, {
                    filter: (src, dest) => {
                        // 不复制 .git 目录
                        return !src.includes('.git');
                    }
                });
            }

            addLog('deploy.git.adding.files');
            
            // Git 操作
            await runCommand('git', ['add', '.'], { cwd: deployDir });

            // 检查是否有变更
            try {
                await runCommand('git', ['diff', '--staged', '--quiet'], { cwd: deployDir });
                addLog('deploy.git.no.changes');
                return; // 没有变更，直接返回
            } catch (error) {
                // 有变更，继续提交
                addLog('deploy.git.committing');
            }

            await runCommand('git', ['commit', '-m', commitMessage], { cwd: deployDir });

            addLog('deploy.git.pushing');
            await runCommand('git', ['push', 'origin', config.branch || 'main'], { cwd: deployDir });
            
            addLog('deploy.git.success');
        };

        // 开始部署流程
        (async () => {
            try {
                if (skipGenerate) {
                    // 跳过生成模式
                    addLog('deploy.skip.generate.mode');
                    
                    await updateStatus({ stage: 'deploying', progress: 30 });
                } else {
                    // 标准模式：清理
                    await updateStatus({ stage: 'cleaning', progress: 10 });
                    addLog('deploy.cleaning');
                    await runCommand('npx', ['hexo', 'clean'], { cwd: baseDir });

                    // 生成
                    await updateStatus({ stage: 'generating', progress: 30 });
                    addLog('deploy.generating');
                    await runCommand('npx', ['hexo', 'generate'], { cwd: baseDir });
                    
                    await updateStatus({ stage: 'deploying', progress: 60 });
                }

                // 自定义 Git 部署
                addLog('deploy.deploying');
                await customGitDeploy(baseDir, config, skipGenerate);

                // 完成
                const now = new Date();
                const formattedTime = formatDateTime(now);

                // 更新配置文件中的最后部署时间
                config.lastDeployTime = now.toISOString();
                fs.writeFileSync(
                    path.join(baseDir, 'deploy_config.json'),
                    JSON.stringify(config, null, 2)
                );

                await updateStatus({
                    isDeploying: false,
                    progress: 100,
                    stage: 'completed',
                    lastDeployTime: formattedTime
                });

                addLog('deploy.success');
            } catch (error) {
                console.error('部署过程出错:', error);
                await updateStatus({
                    isDeploying: false,
                    stage: 'failed',
                    error: error.message
                });
                addLog(`deploy.failed`);
                addLog(error.message);
            }
        })();
    }

    // 重置部署状态
    use('deploy/reset-status', function (req, res, next) {
        if (req.method !== 'POST') return next();

        try {
            deployStatusDb.update(
                { type: 'status' },
                {
                    $set: {
                        isDeploying: false,
                        progress: 0,
                        stage: 'idle',
                        error: null,
                        logs: ['deploy.status.reset']
                    }
                },
                {},
                (err) => {
                    if (err) {
                        console.error('重置部署状态失败:', err);
                        return res.send(500, '重置部署状态失败');
                    }

                    res.done({
                        success: true,
                        message: 'deploy.status.reset'
                    });
                }
            );
        } catch (error) {
            console.error('重置部署状态失败:', error);
            res.send(500, `重置部署状态失败: ${error.message}`);
        }
    });

    // 清理部署目录
    use('deploy/cleanup', function (req, res, next) {
        if (req.method !== 'POST') return next();

        try {
            const deployDir = path.join(hexo.base_dir, '.deploy_git');
            
            if (fs.existsSync(deployDir)) {
                fse.removeSync(deployDir);
                
                // 同时重置部署状态
                deployStatusDb.update(
                    { type: 'status' },
                    {
                        $set: {
                            isDeploying: false,
                            progress: 0,
                            stage: 'idle',
                            error: null,
                            logs: ['deploy.cleanup.success']
                        }
                    },
                    {},
                    (err) => {
                        if (err) {
                            console.error('重置部署状态失败:', err);
                        }
                    }
                );

                res.done({
                    success: true,
                    message: '部署目录已清理，下次部署将重新克隆仓库'
                });
            } else {
                res.done({
                    success: true,
                    message: '部署目录不存在，无需清理'
                });
            }
        } catch (error) {
            console.error('清理部署目录失败:', error);
            res.send(500, `清理部署目录失败: ${error.message}`);
        }
    });
};const path = require('path');
const fs = require('fs-extra');
const multer = require('multer');
const { v4: uuidv4 } = require('uuid');
const utils = require('./utils');

module.exports = function (app, hexo, use) {
     // 配置multer存储
     const storage = multer.diskStorage({
        destination: function (req, file, cb) {
            // 确保图片目录存在
            const imagesDir = path.join(hexo.source_dir, 'images');
            fs.ensureDirSync(imagesDir);
            cb(null, imagesDir);
        },
        filename: function (req, file, cb) {
            // 生成唯一文件名
            const uniqueName = `${uuidv4()}${path.extname(file.originalname)}`;
            cb(null, uniqueName);
        }
    });
    
    // 创建multer上传实例
    const upload = multer({ storage: storage });

    // 获取图片列表
    use('images/list', function (req, res) {
        const page = parseInt(req.query.page) || 1;
        const pageSize = parseInt(req.query.pageSize) || 10;
        const folder = req.query.folder || '';
        
        const imagesDir = path.join(hexo.source_dir, 'images');
        const targetDir = folder ? path.join(imagesDir, folder) : imagesDir;
        
        // 确保目录存在
        fs.ensureDirSync(targetDir);
        
        // 获取所有文件夹
        const folders = [];
        try {
            const items = fs.readdirSync(imagesDir);
            items.forEach(item => {
                const itemPath = path.join(imagesDir, item);
                if (fs.statSync(itemPath).isDirectory()) {
                    folders.push(item);
                }
            });
        } catch (err) {
            console.error('读取文件夹失败:', err);
        }
        
        // 获取当前文件夹下的所有图片
        let images = [];
        try {
            const items = fs.readdirSync(targetDir);
            items.forEach(item => {
                const itemPath = path.join(targetDir, item);
                const stat = fs.statSync(itemPath);
                if (stat.isFile() && /\.(jpg|jpeg|png|gif|webp|svg)$/i.test(item)) {
                    const relativePath = folder ? `images/${folder}/${item}` : `images/${item}`;
                    images.push({
                        name: item,
                        path:`/${relativePath}`,
                        url: `${hexo.config.url}/${relativePath}`,
                        size: stat.size,
                        lastModified: stat.mtime
                    });
                }
            });
        } catch (err) {
            console.error('读取图片失败:', err);
        }
        
        // 排序和分页
        images.sort((a, b) => b.lastModified - a.lastModified);
        const total = images.length;
        const startIndex = (page - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const paginatedImages = images.slice(startIndex, endIndex);
        
        res.done({
            images: paginatedImages,
            folders: folders,
            total: total,
            page: page,
            pageSize: pageSize
        });
    });
    
    // 创建文件夹
    use('images/createFolder', function (req, res) {
        const folderName = req.body.folderName;
        if (!folderName) {
            return res.send(400, '文件夹名称不能为空');
        }
        
        // 验证文件夹名称 - 修改正则表达式以支持中文
        if (!/^[\w\u4e00-\u9fa5\-]+$/.test(folderName)) {
            return res.send(400, '文件夹名称只能包含字母、数字、下划线、短横线和中文');
        }
        
        const folderPath = path.join(hexo.source_dir, 'images', folderName);
        
        try {
            if (fs.existsSync(folderPath)) {
                return res.send(400, '文件夹已存在');
            }
            
            fs.ensureDirSync(folderPath);
            res.done({ success: true, folderName: folderName });
        } catch (err) {
            console.error('创建文件夹失败:', err);
            res.send(500, '创建文件夹失败: ' + err.message);
        }
    });
    
    // 删除图片
    use('images/delete', function (req, res) {
        const imagePath = req.body.path;
        if (!imagePath) {
            return res.send(400, '图片路径不能为空');
        }
        
        const fullPath = path.join(hexo.source_dir, imagePath);
        
        try {
            if (!fs.existsSync(fullPath)) {
                return res.send(404, '图片不存在');
            }
            
            fs.removeSync(fullPath);
            res.done({ success: true });
        } catch (err) {
            console.error('删除图片失败:', err);
            res.send(500, '删除图片失败: ' + err.message);
        }
    });
    
    // 上传图片 - 修改为支持表单数据上传
    use('images/upload', function (req, res, next) {
        // 检查是否为表单数据上传
        if (req.headers['content-type'] && req.headers['content-type'].includes('multipart/form-data')) {
            // 使用multer处理单个文件上传
            upload.single('data')(req, res, function (err) {
                if (err) {
                    console.error('文件上传失败:', err);
                    return res.send(500, '文件上传失败: ' + err.message);
                }
                
                if (!req.file) {
                    return res.send(400, '没有上传文件');
                }
                
                try {
                    // 获取文件信息
                    const file = req.file;
                    const folder = req.body.folder || '';
                    let filename = req.body.filename || path.basename(file.filename);
                    
                    // 确定保存路径
                    const sourceImagesDir = path.join(hexo.source_dir, 'images');
                    const targetDir = folder 
                        ? path.join(sourceImagesDir, folder) 
                        : sourceImagesDir;
                    
                    // 确保目录存在
                    fs.ensureDirSync(targetDir);
                    
                    // 如果文件已经在临时目录，移动到目标目录
                    const finalFilePath = path.join(targetDir, filename);
                    
                    // 检查文件是否已存在
                    if (fs.existsSync(finalFilePath)) {
                        // 如果文件已存在，添加时间戳
                        const nameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));
                        const extension = filename.substring(filename.lastIndexOf('.'));
                        filename = `${nameWithoutExt}_${Date.now()}${extension}`;
                    }
                    
                    // 移动文件到最终位置
                    fs.moveSync(file.path, path.join(targetDir, filename), { overwrite: false });
                    
                    // 返回图片URL
                    const relativePath = folder 
                        ? `images/${folder}/${filename}` 
                        : `images/${filename}`;
                    
                    res.done({
                        code: 0,
                        url: hexo.config.url +  `/${relativePath}`,
                        path: `/${relativePath}`,
                        name: filename,
                        src:  hexo.config.url + `/${relativePath}` // 添加src字段以兼容现有代码
                    });
                } catch (err) {
                    console.error('保存图片失败:', err);
                    res.send(500, '保存图片失败: ' + err.message);
                }
            });
        } else {
            // 处理Base64上传方式
            const data = req.body.data;
            let filename = req.body.filename || '';
            const folder = req.body.folder || '';
            
            if (!data) {
                return res.send(400, '图片数据不能为空');
            }
            
            // 处理Base64图片数据
            const matches = data.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/);
            if (!matches || matches.length !== 3) {
                return res.send(400, '无效的图片数据');
            }
            
            const type = matches[1];
            const imageBuffer = Buffer.from(matches[2], 'base64');
            
            // 如果没有提供文件名，生成一个唯一的文件名
            if (!filename) {
                // 修复SVG+XML扩展名问题
                let extension = type.split('/')[1];
                // 特殊处理SVG+XML类型
                if (extension === 'svg+xml') {
                    extension = 'svg';
                }
                filename = `${uuidv4()}.${extension}`;
            } else {
                // 确保文件名有正确的扩展名
                let extension = type.split('/')[1];
                // 特殊处理SVG+XML类型
                if (extension === 'svg+xml') {
                    extension = 'svg';
                }
                if (!filename.endsWith(`.${extension}`)) {
                    filename = `${filename}.${extension}`;
                }
            }
            
            // 确定保存路径
            const targetDir = folder 
                ? path.join(hexo.source_dir, 'images', folder) 
                : path.join(hexo.source_dir, 'images');
            
            // 确保目录存在
            fs.ensureDirSync(targetDir);
            
            const filePath = path.join(targetDir, filename);
            
            // 检查文件是否已存在
            if (fs.existsSync(filePath)) {
                // 如果文件已存在，添加时间戳
                const nameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));
                const extension = filename.substring(filename.lastIndexOf('.'));
                filename = `${nameWithoutExt}_${Date.now()}${extension}`;
            }
            
            const finalFilePath = path.join(targetDir, filename);
            
            try {
                fs.writeFileSync(finalFilePath, imageBuffer);
                
                // 返回图片URL
                const relativePath = folder 
                    ? `images/${folder}/${filename}` 
                    : `images/${filename}`;
                    
                res.done({
                    code: 0,
                    url: `${hexo.config.url}/${relativePath}`,
                    path: `/${relativePath}`,
                    name: filename,
                    src: `${hexo.config.url}/${relativePath}` // 添加src字段以兼容现有代码
                });
            } catch (err) {
                console.error('保存图片失败:', err);
                res.send(500, '保存图片失败: ' + err.message);
            }
        }
    });
    
    // 重命名图片
    use('images/rename', function (req, res) {
        const oldPath = req.body.oldPath;
        const newName = req.body.newName;
        
        if (!oldPath || !newName) {
            return res.send(400, '缺少必要参数');
        }
        
        // 验证新文件名 - 修改正则表达式以支持中文
        if (!/^[\w\u4e00-\u9fa5\-\.]+$/.test(newName)) {
            return res.send(400, '文件名只能包含字母、数字、下划线、短横线、点和中文');
        }
        
        const fullOldPath = path.join(hexo.source_dir, oldPath);
        
        if (!fs.existsSync(fullOldPath)) {
            return res.send(404, '图片不存在');
        }
        
        const dirName = path.dirname(fullOldPath);
        const extension = path.extname(fullOldPath);
        const newNameWithExt = newName.includes('.') ? newName : `${newName}${extension}`;
        const fullNewPath = path.join(dirName, newNameWithExt);
        
        if (fs.existsSync(fullNewPath)) {
            return res.send(400, '该文件名已存在');
        }
        
        try {
            fs.renameSync(fullOldPath, fullNewPath);
            
            // 计算新的相对路径
            const relativePath = path.relative(hexo.source_dir, fullNewPath).replace(/\\/g, '/');
            
            res.done({
                success: true,
                newPath: `/${relativePath}`,
                url: `${hexo.config.url}/${relativePath}`,
                name: newNameWithExt
            });
        } catch (err) {
            console.error('重命名图片失败:', err);
            res.send(500, '重命名图片失败: ' + err.message);
        }
    });
    
    // 移动图片到指定文件夹
    use('images/move', function (req, res) {
        const imagePath = req.body.path;
        const targetFolder = req.body.targetFolder || '';
        
        if (!imagePath) {
            return res.send(400, '图片路径不能为空');
        }
        
        const fullPath = path.join(hexo.source_dir, imagePath);
        
        if (!fs.existsSync(fullPath)) {
            return res.send(404, '图片不存在');
        }
        
        const fileName = path.basename(fullPath);
        const targetDir = targetFolder 
            ? path.join(hexo.source_dir, 'images', targetFolder) 
            : path.join(hexo.source_dir, 'images');
        
        // 确保目标目录存在
        fs.ensureDirSync(targetDir);
        
        let targetPath = path.join(targetDir, fileName);  // 改为 let 声明
        
        // 检查目标路径是否已存在同名文件
        if (fs.existsSync(targetPath)) {
            const nameWithoutExt = fileName.substring(0, fileName.lastIndexOf('.'));
            const extension = fileName.substring(fileName.lastIndexOf('.'));
            const newFileName = `${nameWithoutExt}_${Date.now()}${extension}`;
            targetPath = path.join(targetDir, newFileName);
        }
        
        try {
            fs.moveSync(fullPath, targetPath);
            
            // 计算新的相对路径
            const relativePath = path.relative(hexo.source_dir, targetPath).replace(/\\/g, '/');
            
            res.done({
                success: true,
                newPath: `/${relativePath}`,
                url: `${hexo.config.url}/${relativePath}`,
                name: path.basename(targetPath)
            });
        } catch (err) {
            console.error('移动图片失败:', err);
            res.send(500, '移动图片失败: ' + err.message);
        }
    });
};'use strict';
var serveStatic = require('serve-static');
var path = require('path');
var api = require('./api');
const { expressjwt: jwt } = require('express-jwt')
const fs = require('fs');
const mime = require('mime')
// 添加查询字符串解析中间件
const querystring = require('querystring');
const crypto = require('crypto');

// 修改：不再从 _config.yml 获取登录信息，而是在 api 中根据数据库判断
let needLogin = false; // 默认不需要登录，将在 api.js 中根据数据库内容决定

function staticMiddleware(rootDir) {
    return function (req, res, next) {
        // 获取请求的文件路径
        const filePath = path.join(rootDir, req.url);

        // 使用 fs 模块检查文件是否存在
        fs.exists(filePath, (exists) => {
            if (!exists) {
                // 如果文件不存在，调用 next() 将请求传递给下一个中间件或路由处理程序
                return next();
            }

            // 使用 mime 模块获取文件的 MIME 类型
            const contentType = mime.getType(filePath);

            // 设置响应头，指定正确的 MIME 类型
            res.setHeader('Content-Type', contentType);

            // 使用 fs 模块创建可读流并将文件内容传输到响应
            const fileStream = fs.createReadStream(filePath);
            fileStream.pipe(res);
        });
    };
}


function buildIndex() {
    class BlogInfo {
        constructor(title, content, isPage, isDraft, permalink) {
            this.title = title
            this.content = content
            this.isPage = isPage
            this.isDraft = isDraft
            this.permalink = permalink
        }
    }

    const posts = hexo.model('Post').toArray()
    const pages = hexo.model('Page').toArray()

    const blogInfoList = []

    posts.forEach((post, _) => {
        blogInfoList.push(new BlogInfo(post.title, post.content, false, !post.published, post.permalink))
    })

    pages.forEach((page, _) => {
        blogInfoList.push(new BlogInfo(page.title, page.content, true, false, page.permalink))
    })

    fs.writeFileSync(path.join(hexo.base_dir, 'blogInfoList.json'), JSON.stringify(blogInfoList))
}

const serve = serveStatic(path.join(__dirname, 'www'))

hexo.extend.filter.register('before_generate', function () {
    buildIndex();
    // 在生成之前执行的逻辑
});

hexo.extend.filter.register('after_init', async function () {
    await hexo.load(); // 确保所有数据已加载
    // 将博客数据写入到文件当中
    buildIndex();
});

hexo.extend.filter.register('after_post_render', function (data) {
    return data;
});

hexo.extend.filter.register('server_middleware', function (app) {

    // 添加查询字符串解析中间件
    app.use((req, res, next) => {
        if (!req.query && req.url.includes('?')) {
            const queryStr = req.url.split('?')[1];
            req.query = querystring.parse(queryStr);
        }
        next();
    });

    // console.log("posts=>", hexo.locals.get("posts"))
    // 检查请求的URL是否以静态文件后缀结尾
    app.use((req, res, next) => {
        // 将所有请求重定向到你的应用程序的入口点
        if (req.originalUrl.startsWith('/pro')) {
            const isStaticFile = ['.html', '.css', '.js', '.jpg', '.png', '.gif'].some(extension => req.originalUrl.endsWith(extension));
            let filePath = path.join(__dirname, 'www', "index.html");
            if (isStaticFile) {
                filePath = path.join(__dirname, 'www', req.originalUrl.substring(4));
            }
            // 使用 fs 模块读取文件并将其发送给客户端
            fs.readFile(filePath, (err, data) => {
                if (err) {
                    // 处理文件读取错误
                    res.writeHead(404, { 'Content-Type': 'text/plain' });
                    res.end('File not found');
                } else {
                    // 发送文件内容
                    // 使用 mime 模块获取文件的 MIME 类型
                    const contentType = mime.getType(filePath);

                    res.writeHead(200, { 'Content-Type': contentType });
                    res.end(data);
                }
            });
            // staticMiddleware()
        } else {
            next();
        }
    });
    app.use('/pro', serve);

    console.log(hexo.config.root)

    let root = hexo.config.root
    if (!root) {
        root = ''
    }

    const unlessPaths = [
        hexo.config.root + 'hexopro/api/login', 
        hexo.config.root + 'hexopro/api/settings/check-first-use',
        hexo.config.root + 'hexopro/api/settings/register',
        hexo.config.root + 'pro'
    ]
    console.log(unlessPaths)
    // 初始化数据库并获取 API
    // api(app, hexo, needLogin); // 旧的调用方式
    api(app, hexo).catch(err => { // 调用 async 函数，并添加错误处理
        console.error('[Hexo Pro]: API 初始化过程中发生未捕获错误:', err);
    });

});

// 导出buildIndex函数供桌面端使用
module.exports = {
    buildIndex: buildIndex
};
MIT License

Copyright (c) [2024] [wuzheng]

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

const jwt = require('jsonwebtoken');

// 移除 _needLogin 和 _jwtSecret 参数
module.exports = function (app, hexo, use, db) {
    const { userDb, settingsDb } = db; // 从 db 中解构 settingsDb

    use('login', function (req, res) {
        // 使用全局变量 global.actualNeedLogin
        if (!global.actualNeedLogin) {
            return res.done({
                code: -2,
                msg: '未配置登录信息，无需登录'
            });
        }

        const { username, password } = req.body;

        // 使用 NeDB 查询用户
        userDb.findOne({ username }, (err, user) => {
            if (err) {
                return res.done({
                    code: 500,
                    msg: '服务器错误'
                });
            }

            if (!user || user.password.toString() !== password) {
                return res.done({
                    code: -1,
                    msg: '用户名或密码错误'
                });
            }

            // 使用全局变量 global.jwtSecret
            if (!global.jwtSecret) {
                 // 尝试从数据库再次加载，以防万一初始化时 global 未设置
                 settingsDb.findOne({ type: 'system' }, (err, settings) => {
                     if (!err && settings && settings.jwtSecret) {
                         global.jwtSecret = settings.jwtSecret;
                         // 继续生成 token
                         generateTokenAndRespond(user, res);
                     } else {
                         console.error('[Hexo Pro Login]: JWT Secret 在登录时仍未配置!');
                         return res.done({
                             code: 500,
                             msg: '系统错误：JWT 密钥未配置'
                         });
                     }
                 });
            } else {
                 // 直接生成 token
                 generateTokenAndRespond(user, res);
            }
        });
    });

    // 辅助函数用于生成 Token 和响应
    function generateTokenAndRespond(user, res) {
        const token = jwt.sign(
            { username: user.username },
            global.jwtSecret,
            { expiresIn: '7d' }
        );

        res.done({
            code: 0,
            msg: '登录成功',
            token
        });
    }


    use('userInfo', function (req, res) {
         // 使用全局变量 global.actualNeedLogin
        if (!global.actualNeedLogin) {
            // 如果不需要登录，可以返回一个默认用户或空信息
            return res.done({
                avatar: '',
                name: 'Guest' // 或者 'Admin'，根据你的逻辑
            });
        }

        // 调试信息
        // console.log('userInfo接口被调用');
        // console.log('请求头:', req.headers);
        // console.log('Authorization:', req.headers.authorization);
        // console.log('req.auth:', req.auth);

        let username = null;

        // 首先尝试从req.auth获取用户名
        if (req.auth && req.auth.username) {
            username = req.auth.username;
            // console.log('从req.auth获取到用户名:', username);
        }
        // 如果req.auth不存在，尝试手动解析token
        else if (req.headers.authorization && req.headers.authorization.startsWith('Bearer ')) {
            try {
                const token = req.headers.authorization.split(' ')[1];
                console.log('尝试手动解析token:', token);

                 // 使用全局变量 global.jwtSecret
                if (token && global.jwtSecret) {
                    const decoded = jwt.verify(token, global.jwtSecret);
                    console.log('手动解析token结果:', decoded);

                    if (decoded && decoded.username) {
                        username = decoded.username;
                        console.log('从token中获取到用户名:', username);
                    }
                } else if (token && !global.jwtSecret) {
                     console.warn('[Hexo Pro UserInfo]: 尝试解析Token但 global.jwtSecret 未设置');
                }
            } catch (error) {
                console.error('解析token失败:', error.message);
                 // 如果 token 无效或过期，也视为未授权
                 return res.done({
                     code: 401,
                     msg: 'Token无效或已过期'
                 });
            }
        }

        if (!username) {
            console.log('未获取到用户名，返回401');
            return res.done({
                code: 401,
                msg: '未授权或Token无效' // 更明确的错误信息
            });
        }

        // 从数据库获取用户信息
        userDb.findOne({ username }, (err, user) => {
            if (err) {
                console.log('数据库查询错误:', err);
                return res.done({
                    code: 500,
                    msg: '获取用户信息失败'
                });
            }

            if (!user) {
                console.log('用户不存在:', username);
                return res.done({
                    code: 404,
                    msg: '用户不存在'
                });
            }

            // console.log('成功获取用户信息:', username);
            res.done({
                avatar: user.avatar || '',
                name: user.username
            });
        });
    });
};
{
  "name": "hexo-pro",
  "version": "1.2.6",
  "description": "hexo pro a backend plugin for hexo",
  "main": "index",
  "directories": {
    "doc": "docs"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/wuzheng228/hexo-pro.git"
  },
  "author": "wuzheng",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/wuzheng228/hexo-pro/issues"
  },
  "homepage": "https://github.com/wuzheng228/hexo-pro#readme",
  "dependencies": {
    "axios": "^1.9.0",
    "bcrypt-nodejs": "^0.0.3",
    "body-parser": "^1.20.2",
    "browser-sync": "^3.0.4",
    "cheerio": "^1.0.0",
    "circular-json": "^0.5.9",
    "connect-history-api-fallback": "^2.0.0",
    "express-jwt": "^8.4.1",
    "extend": "^3.0.2",
    "flatted": "^3.2.7",
    "fs-extra": "^11.3.0",
    "fuse.js": "^7.0.0",
    "hexo": "^7.3.0",
    "hexo-deployer-git": "^4.0.0",
    "hexo-front-matter": "^4.1.0",
    "hexo-fs": "^4.1.1",
    "hexo-util": "^3.1.0",
    "js-yaml": "^4.1.0",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "mime": "^3.0.0",
    "multer": "^1.4.5-lts.2",
    "@seald-io/nedb": "^4.1.1",
    "uuid": "^10.0.0"
  }
}
var path = require('path')
var url = require('url')
var fs = require('hexo-fs')
var fse = require('fs-extra')
var yml = require('js-yaml')
var updateAny = require('./update'),
    update = updateAny.bind(null, 'Page')
var extend = require('extend')
const _ = require('lodash')
var hfm = require('hexo-front-matter')

const utils = require('./utils');

module.exports = function (app, hexo, use) {
    function addIsDraft(post) {
        post.isDraft = post?.source && post?.source.indexOf('_draft') === 0 || false
        post.isDiscarded = post?.source && post?.source.indexOf('_discarded') === 0 || false
        post.updated = formatDateTime(post.updated)
        post.date = formatDateTime(post.date)
        return post
    }

    function addFormatDateTime(page) {
        // page.isDiscarded = page.source && page.source.indexOf('_discarded') === 0
        page.updated = formatDateTime(page.updated)
        page.date = formatDateTime(page.date)
        return page
    }

    function formatDateTime(dateString) {
        const date = new Date(dateString);

        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');

        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }
    function remove(id, body, res) {
        id = utils.base64Decode(id)
        var page = hexo.model('Page').filter(p => p.permalink === id).data[0]
        if (!page) return res.send(404, "Post not found")

        // 生成唯一路径：_discarded/<timestamp>/original_path
        const timestamp = Date.now()
        const originalFilename = path.basename(page.source)
        const originalDirname = path.dirname(page.source);
        const newSource = path.join('_discarded', String(timestamp), originalDirname, originalFilename);

        // 物理移动文件
        const oldPath = path.join(hexo.source_dir, page.source)
        const newDir = path.join(hexo.source_dir, path.dirname(newSource))
        const newPath = path.join(newDir, originalFilename)

        // 使用 fse 移动文件到新路径下
        fse.ensureDir(newDir, err => {
            if (err) return res.send(500, `Failed to create directory: ${err.message}`);
            fse.move(oldPath, newPath, { overwrite: false }, err => {
                if (err) return res.send(500, `File operation failed: ${err.message}`);

                // 从数据模型中删除页面记录
                hexo.model('Page').remove({ _id: page._id }, err => {
                    if (err) return res.send(500, `Failed to remove page from model: ${err.message}`);

                    // 刷新 Hexo 数据
                    hexo.source.process().then(() => {
                        res.done(addIsDraft(page))
                    }).catch(e => {
                        console.error(e, e.stack)
                        res.send(500, 'Failed to refresh data')
                    })
                });
            });
        });
    }

    async function createPageManually(req, res) {
        if (!req.body) {
            return res.send(400, 'No page body given');
        }
        if (!req.body.title) {
            return res.send(400, 'No title given');
        }

        // 生成唯一文件名
        let title = req.body.title;
        let filePath = path.join(hexo.source_dir, `${title}/index.md`);

        // 检查文件是否存在
        const exists = fse.pathExistsSync(filePath);
        if (exists) {
            // 如果存在，自动添加时间戳后缀
            title = `${title} (${Date.now()})`;
            filePath = path.join(hexo.source_dir, `${title}/index.md`);
            // 不返回错误，而是继续创建带有新标题的页面
        }

        // 生成页面的元数据
        const frontMatter = {
            title: title,
            layout: 'page',
            date: new Date(),
            updated: new Date(),
        };

        // 将元数据转换为 YAML 格式
        const frontMatterYaml = hfm.stringify(frontMatter);

        // 页面内容，这里可以根据需要修改
        const pageContent = `${frontMatterYaml}`;

        // 创建文件并写入内容
        await fs.writeFile(filePath, pageContent, async (err) => {
            if (err) {
                console.error(err);
                return res.send(500, 'Failed to create page');
            }
        });

        // 通知 Hexo 重新处理数据源
        await hexo.source.process().then(() => {
            console.log('Page created:', filePath);
        }).catch(e => {
            console.error(e);
            res.send(500, 'Failed to refresh data');
        });

        var page = hexo.model('Page').findOne({ source: filePath.slice(hexo.source_dir.length).replace(/\\/g, '/') });
        
        // 如果存在重名情况，在返回结果中添加提示信息
        if (exists) {
            page.titleChanged = true; // 添加标志，前端可以据此显示提示
            page.originalTitle = req.body.title; // 保存原始标题
        }
        
        return res.done(addFormatDateTime(page));
    }

    // 检查页面是否存在
    use('pages/check-exists', function (req, res, next) {
        if (req.method !== 'GET') return next();
        
        const parsedUrl = url.parse(req.url, true);
        const queryParams = parsedUrl.query;
        const { path: pagePath } = queryParams;  // 将参数名改为 pagePath
        
        if (!pagePath) {
            return res.send(400, 'No path provided');
        }
        
        const filePath = path.join(hexo.source_dir, pagePath);
        const exists = fse.pathExistsSync(filePath);
        
        return res.done({ exists });
    });

    use('pages/list', function (req, res) {
        const parsedUrl = url.parse(req.url, true);
        const queryParams = parsedUrl.query;
        const { deleted, page = 1, pageSize = 12 } = queryParams;

        var pageModel = hexo.model('Page');
        let pages = pageModel.toArray()
            .map(page => {
                const { site, raw, content, _content, more, ...rest } = page;
                return rest;
            })
            .map(addIsDraft);

        if (deleted == 'false') {
            pages = pages.filter(page => page.isDiscarded == false);
        }

        // 排序逻辑
        var sortedList = pages.sort(function (a, b) {
            return new Date(b.date) - new Date(a.date);
        });

        // 分页处理
        const total = sortedList.length;
        const startIndex = (Math.max(parseInt(page), 1) - 1) * parseInt(pageSize);
        const endIndex = startIndex + parseInt(pageSize);
        const paginatedData = sortedList.slice(startIndex, endIndex);

        res.done({
            total: total,
            data: paginatedData
        });
    });

    use('pages/new', function (req, res, next) {
        if (req.method !== 'POST') return next();
        createPageManually(req, res);
    });

    use('pages/:id', function (req, res, next) {
        var id = req.params.id
        if (id === 'pages' || !id) return next()
        if (req.method === 'GET') {
            id = utils.base64Decode(id)
            var page = hexo.model('Page').filter(p => p.permalink === id)
            if (!page) return next()
            page = page.data[0]
            return res.done(addIsDraft(page))
        }

        if (!req.body) {
            return res.send(400, 'No page body given');
        }

        id = req.body._id

        update(id, req.body.update, function (err, page) {
            if (err) {
                return res.send(400, err);
            }
            res.done({
                page: addIsDraft(page)
            })
        }, hexo);
    });

    use('pages/:id/:action', function (req, res, next) {
        const id = req.params.id
        const action = req.params.action

        if (action === 'remove') {
            return remove(id, req.body, res)
        }
        if (action === 'rename') {
            return rename(id, req.body, res)
        }
    });

    use('page/update', function (req, res, next) {

        if (!req.body) {
            return res.send(400, 'No page body given');
        }

        id = req.body._id

        update(id, req.body.update, function (err, page) {
            if (err) {
                return res.send(400, err);
            }
            res.done({
                page: addIsDraft(page)
            })
        }, hexo);
    });

    use('pageMeta/:id', function (req, res, next) {
        var id = req.params.id
        if (req.method === 'GET') {
            id = utils.base64Decode(id)
            var post = hexo.model('Page').filter(p => p.permalink === id).data[0]
            if (!post) next()
            var split = hfm.split(post.raw)
            var parsed = hfm.parse([split.data, '---'].join('\n'))
            const { title, author, date, _content, ...rest } = parsed
            if (typeof rest['categories'] === 'string') {
                rest['categories'] = [rest['categories']]
            }
            if (typeof rest['tags'] === 'string') {
                rest['tags'] = [rest['tags']]
            }
            if (!rest.tags) {
                rest.tags = []
            }
            if (!rest.categories) {
                rest.categories = []
            }
            const ans = {}
            ans.categories = rest.categories
            ans.tags = rest.tags
            const fm = {}
            Object.keys(rest).forEach((name) => {
                if (name == 'categories' || name == 'tags') {
                    return
                }
                fm[name] = rest[name]
            })
            ans.frontMatter = fm
            ans.source = post.source
            return res.done(ans)
        }
    })

    use('updatePageFrontMatter', function (req, res, next) {
            if (req.method !== 'POST') return next();
            if (!req.body) {
                return res.send(500, 'No post body given');
            }
            if (!req.body.permalink) {
                return res.send(500, 'No permalink given');
            }
            if (!req.body.key || !req.body.value) {
                return res.send(500, 'Key or value missing');
            }
    
            const permalink = req.body.permalink;
            const key = req.body.key;
            const value = req.body.value;
    
            // 构建更新对象
            const frontMatterUpdate = {};
            frontMatterUpdate[key] = value;
    
            // 使用update函数更新文章
            update(permalink, { frontMatter: frontMatterUpdate }, function (err, post) {
                if (err) {
                    return res.send(400, err);
                }
                post = _.cloneDeep(post);
                res.done(addIsDraft(post));
            }, hexo);
        });

}var path = require('path')
var url = require('url')
var fs = require('hexo-fs')
var fse = require('fs-extra')
var yml = require('js-yaml')
var updateAny = require('./update'),
    update = updateAny.bind(null, 'Post')
var extend = require('extend')
const _ = require('lodash')
var hfm = require('hexo-front-matter')
const Fuse = require('fuse.js')
const cheerio = require('cheerio')
const { v4: uuidv4 } = require('uuid');

const utils = require('./utils');
const { permalink } = require('hexo/dist/hexo/default_config')


module.exports = function (app, hexo, use) {
    // reads admin panel settings from _admin-config.yml
    // or writes it if it does not exist
    function getSettings() {
        var path = hexo.base_dir + '_admin-config.yml'
        if (!fs.existsSync(path)) {
            hexo.log.d('admin config not found, creating one')
            fs.writeFile(hexo.base_dir + '_admin-config.yml', '')
            return {}
        } else {
            var settings = yml.load(fs.readFileSync(path))

            if (!settings) return {}
            return settings
        }
    }
    function tagsCategoriesAndMetadata() {
        var cats = {}
            , tags = {}
        hexo.model('Category').forEach(function (cat) {
            cats[cat._id] = cat.name
        })
        hexo.model('Tag').forEach(function (tag) {
            tags[tag._id] = tag.name
        })
        return {
            categories: cats,
            tags: tags,
            metadata: Object.keys(hexo.config.metadata || {})
        }
    }
    function addIsDraft(post) {
        if (!post) return post
        post.isDraft = post.source?.indexOf('_draft') === 0
        post.isDiscarded = post.source?.indexOf('_discarded') === 0
        post.updated = formatDateTime(post.updated)
        post.date = formatDateTime(post.date)
        return post
    }
    function publish(permalink, body, res) {
        // 优先通过ID查找，找不到时通过文件名查找
        permalink = utils.base64Decode(permalink)
        var post = hexo.model('Post').filter(p => p.permalink === permalink).data[0];

        if (!post) return res.send(404, "Post not found");

        const originalFilename = path.basename(post.source);
        const originalDirname = path.dirname(post.source);
        const newSource = '_posts/' + originalFilename;
        const oldPath = path.join(hexo.source_dir, post.source);
        const newDir = path.join(hexo.source_dir, path.dirname(newSource));
        const newPath = path.join(newDir, originalFilename);

        // 使用 fse 确保目录存在
        fse.ensureDir(newDir, err => {
            if (err) return res.send(500, `Failed to create directory: ${err.message}`);

            // 使用 fse 移动文件到新路径下
            fse.move(oldPath, newPath, { overwrite: false }, async err => {
                if (err) return res.send(500, `File operation failed: ${err.message}`);

                // 更新数据模型中的 post 源路径
                post.source = newSource;
                post = _.cloneDeep(post);

                // 刷新 Hexo 数据
                await hexo.source.process().then(() => {
                    res.done(addIsDraft(post))
                }).catch(e => {
                    console.error(e, e.stack)
                    res.send(500, 'Failed to refresh data')
                })
                // 直接更新数据库中的source路径
                // hexo.model('Post').update(post._id, { source: newSource });
                // res.done(addIsDraft(post));
            });
        });
    }

    function unpublish(permalink, body, res) {
        // 优先通过ID查找，找不到时通过文件名查找
        permalink = utils.base64Decode(permalink)
        var post = hexo.model('Post').filter(p => p.permalink === permalink).data[0];
        if (!post) return res.send(404, "Post not found");

        const originalFilename = path.basename(post.source);
        const originalDirname = path.dirname(post.source);
        const newSource = '_drafts/' + originalFilename;
        const oldPath = path.join(hexo.source_dir, post.source);
        const newDir = path.join(hexo.source_dir, path.dirname(newSource));
        const newPath = path.join(newDir, originalFilename);

        // 使用 fse 确保目录存在
        fse.ensureDir(newDir, err => {
            if (err) return res.send(500, `Failed to create directory: ${err.message}`);

            // 使用 fse 移动文件到新路径下
            fse.move(oldPath, newPath, { overwrite: false }, async err => {
                if (err) return res.send(500, `File operation failed: ${err.message}`);

                // 更新数据模型中的 post 源路径
                post.source = newSource;
                post = _.cloneDeep(post);

                // 刷新 Hexo 数据
                await hexo.source.process().then(() => {
                    res.done(addIsDraft(post))
                }).catch(e => {
                    console.error(e, e.stack)
                    res.send(500, 'Failed to refresh data')
                })
                // // 直接更新数据库中的source路径
                // hexo.model('Post').update(post._id, { source: newSource });
                // res.done(addIsDraft(post));
            });
        });
    }

    function formatDateTime(dateString) {
        const date = new Date(dateString);

        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');

        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }
    function remove(id, body, res) {
        id = utils.base64Decode(id)
        var post = hexo.model('Post').filter(p => p.permalink === id).data[0];
        post = _.cloneDeep(post)
        if (!post) return res.send(404, "Post not found")

        const originalFilename = path.basename(post.source)
        const originalDirname = path.dirname(post.source)
        const newSource = path.join('_discarded', String(Date.now()), originalDirname, originalFilename)
        const oldPath = path.join(hexo.source_dir, post.source)
        const newDir = path.join(hexo.source_dir, path.dirname(newSource))
        const newPath = path.join(newDir, originalFilename)

        // 使用 fse 确保目录存在
        fse.ensureDir(newDir, err => {
            if (err) return res.send(500, `Failed to create directory: ${err.message}`)

            // 使用 fse 移动文件到新路径下
            fse.move(oldPath, newPath, { overwrite: false }, err => {
                if (err) return res.send(500, `File operation failed: ${err.message}`)
                // 从数据模型中删除页面记录
                hexo.model('Post').remove({ _id: post._id }, err => {
                    if (err) return res.send(500, `Failed to remove post from model: ${err.message}`)

                    // 刷新 Hexo 数据
                    hexo.source.process().then(() => {
                        res.done(addIsDraft(post))
                    }).catch(e => {
                        console.error(e, e.stack)
                        res.send(500, 'Failed to refresh data')
                    })
                })

            })
        })
    }

    function loadBlogInfoList() {
        const blogInfoList = fs.readFileSync(path.join(hexo.base_dir, 'blogInfoList.json'));
        return JSON.parse(blogInfoList);
    }
    function getHighlightedTextFromHtml(content, searchPattern, contextLength = 40) {
        if (!content || content.trim() === '') {
            return '...'
        }
        // 使用 cheerio 移除 HTML 标签
        const $ = cheerio.load(content);
        content = $.text();

        content = content.replace(/[\n\r]+/g, ' ').replace(/\s+/g, ' ').trim();

        // 安全地处理搜索模式
        const safePattern = searchPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // 转义特殊字符
        const regex = new RegExp(safePattern, 'gi');

        const matchIndices = [...content.matchAll(regex)].map(m => m.index);

        // 如果没有匹配项，返回内容的前300个字符
        if (matchIndices.length === 0)
            return content.substring(0, Math.min(content.length, 300)) + '...';

        // 计算匹配项之间的平均距离
        const totalDistance = matchIndices.slice(1).reduce((acc, index, i) => acc + (index - matchIndices[i]), 0);
        const averageDistance = matchIndices.length > 1 ? totalDistance / (matchIndices.length - 1) : 0;

        // 根据平均距离调整 contextLength
        contextLength = averageDistance < 50 ? Math.min(80, content.length) : Math.min(40, content.length);

        // 创建匹配片段
        let segments = [];
        let processedIndices = new Set();

        // 首先处理彼此接近的匹配项，将它们合并为一个片段
        for (let i = 0; i < matchIndices.length; i++) {
            if (processedIndices.has(i)) continue;

            const currentIndex = matchIndices[i];
            let endIndex = currentIndex;
            let j = i + 1;

            // 查找接近的匹配项
            while (j < matchIndices.length && matchIndices[j] - endIndex < contextLength * 2) {
                endIndex = matchIndices[j];
                processedIndices.add(j);
                j++;
            }

            // 创建包含多个匹配项的片段
            const start = Math.max(currentIndex - contextLength, 0);
            const end = Math.min(endIndex + searchPattern.length + contextLength, content.length);
            let segment = content.substring(start, end);

            // 计算此片段中包含的匹配项数量
            const matchCount = segment.match(regex)?.length || 0;

            segments.push({
                text: segment.replace(regex, '<mark>$&</mark>'),
                matchCount: matchCount,
                originalIndex: i
            });
        }

        // 处理剩余的单个匹配项
        for (let i = 0; i < matchIndices.length; i++) {
            if (processedIndices.has(i)) continue;

            const index = matchIndices[i];
            const start = Math.max(index - contextLength, 0);
            const end = Math.min(index + searchPattern.length + contextLength, content.length);
            let segment = content.substring(start, end);

            segments.push({
                text: segment.replace(regex, '<mark>$&</mark>'),
                matchCount: 1,
                originalIndex: i
            });
        }

        // 按匹配数量排序，优先显示包含多个匹配项的片段
        segments.sort((a, b) => {
            // 首先按匹配数量降序排序
            if (b.matchCount !== a.matchCount) {
                return b.matchCount - a.matchCount;
            }
            // 匹配数量相同时，按原始顺序排序
            return a.originalIndex - b.originalIndex;
        });

        // 限制片段数量，最多显示3个片段
        segments = segments.slice(0, 3);

        // 按原始顺序重新排序片段
        segments.sort((a, b) => a.originalIndex - b.originalIndex);

        // 组合最终结果
        return segments.map(s => s.text).join('... ') + '...';
    }

    use('blog/search', function (req, res) {
        const fuseOptions = {
            includeScore: true,
            keys: ['title', 'content']
        };

        const blogInfoList = loadBlogInfoList()
        const fuse = new Fuse(blogInfoList, fuseOptions);

        const results = fuse.search(req.body.searchPattern)
        // 返回搜索结果
        const enhancedResults = results.map(result => {
            const { item } = result;
            const highlightedText = getHighlightedTextFromHtml(item.content, req.body.searchPattern);
            return {
                permalink: item.permalink,
                isPage: item.isPage,
                isDraft: item.isDraft,
                title: item.title,
                context: highlightedText,
            }
        })
        res.done({ code: 0, data: enhancedResults })
    });

    use('posts/check-title', function (req, res) {
        const { title, excludeId } = req.query

        // 查找除了指定 ID 外的所有文章
        const posts = hexo.model('Post').filter(p => {
            if (excludeId) {
                const decodedId = utils.base64Decode(excludeId)
                return p.title === title && p.permalink !== decodedId
            }
            return p.title === title
        }).data

        res.done({ exists: posts.length > 0 })
    })

    use('posts/list', function (req, res) {
        const parsedUrl = url.parse(req.url, true);
        const queryParams = parsedUrl.query;
        const { published, page = 1, pageSize = 12 } = queryParams;

        var post = hexo.model('Post');
        var postList = post.toArray();
        var clonedList = _.cloneDeep(postList);
        clonedList.map(addIsDraft);

        let finalList = [];
        if (published == 'true') {
            finalList = clonedList.filter(post => post.isDraft === false && post.isDiscarded === false);
        } else {
            finalList = clonedList.filter(post => post.isDraft === true);
        }

        var sortedList = finalList.sort(function (a, b) {
            var dateA = new Date(a.date);
            var dateB = new Date(b.date);
            return dateB - dateA;
        });

        // 分页处理
        const total = sortedList.length;
        const startIndex = (Math.max(parseInt(page), 1) - 1) * parseInt(pageSize);
        const endIndex = startIndex + parseInt(pageSize);
        const paginatedData = sortedList.slice(startIndex, endIndex);

        res.done({
            total: total,
            data: paginatedData.map(post => {
                const { site, raw, content, more, tags, _content, categories, ...rest } = post;
                return rest;
            })
        });
    });
    use('posts/page/list', function (req, res) {
        const parsedUrl = url.parse(req.url, true);
        const queryParams = parsedUrl.query;
        const { page, pageSize } = queryParams;
        const data = hexo.model('Post')
        // 计算起始索引和结束索引
        const startIndex = (page - 1) * pageSize;
        const endIndex = startIndex + parseInt(pageSize);

        // 根据分页参数截取数据
        const paginatedData = data.slice(startIndex, endIndex);

        res.done(paginatedData);
    });
    use('posts/new', function (req, res, next) {
        if (req.method !== 'POST') return next()
        if (!req.body) {
            return res.send(400, "No post body given")
        }
        if (!req.body.title) {
            return res.send(400, "No title given")
        }

        var postParameters = { title: req.body.title, layout: 'draft', date: new Date(), author: hexo.config.author };
        extend(postParameters, hexo.config.metadata || {})
        hexo.post.create(postParameters)
            .error(function (err) {
                console.error(err, err.stack)
                return res.send(500, 'Failed to create post')
            })
            .then(function (file) {
                var source = file.path.slice(hexo.source_dir.length)
                hexo.source.process([source]).then(function () {
                    var post = _.cloneDeep(hexo.model('Post').findOne({ source: source.replace(/\\/g, '\/') }))

                    return res.done(addIsDraft(post));
                });
            });
    })
    // 查询单个博客信息
    use('posts/:param1/:param2', function (req, res, next) {
        var last = req.params.param2
        if (last === 'publish') {
            // console.log(parts)
            // console.log(typeof parts[parts.length - 2])
            return publish(req.params.param1, req.body, res)
        }
        if (last === 'unpublish') {
            return unpublish(req.params.param1, req.body, res)
        }
        if (last === 'remove') {
            return remove(req.params.param1, req.body, res)
        }
        var id = req.params.param2
        if (id === 'posts' || !id) return next();
        if (req.method === 'GET') {
            id = utils.base64Decode(id)
            console.log("Posts route: Searching for post with id:", id);
            // 使用findOne代替filter+[0]，避免undefined问题
            let post = hexo.model('Post').filter(post => {
                const permalink = post.permalink;
                // console.log("Checking slug:", permalink, "Match result:", id === permalink);
                return id === permalink;
            });
            // 如果没找到匹配的文章
            if (!post) {
                console.log("Posts route: No post found with slug:", id);
                return next();
            }
            post = _.cloneDeep(post.data[0])
            // console.log(Object.keys(post))
            // console.log(post.tags)
            // console.log(post.categories)
            // console.log(post.top_img)
            // var split = hfm.split(post.raw)
            // // console.log('-----> split data', split.data)
            // var parsed = hfm.parse([split.data, '---'].join('\n'))
            // console.log('-----> split parsed', parsed)
            return res.done(addIsDraft(post))
        }

    })

    use('posts/:param1', function (req, res, next) {
        var id = req.params.param1
        if (id === 'posts' || !id) return next();
        if (req.method === 'GET') {
            id = utils.base64Decode(id)
            console.log("Posts route: Searching for post with id:", id);
            // 使用findOne代替filter+[0]，避免undefined问题
            let post = hexo.model('Post').filter(post => {
                const permalink = post.permalink;
                // console.log("Checking slug:", permalink, "Match result:", id === permalink);
                return id === permalink;
            });
            // 如果没找到匹配的文章
            if (!post) {
                console.log("Posts route: No post found with slug:", id);
                return next();
            }
            post = _.cloneDeep(post.data[0])
            // console.log(Object.keys(post))
            // console.log(post.tags)
            // console.log(post.categories)
            // console.log(post.top_img)
            // var split = hfm.split(post.raw)
            // // console.log('-----> split data', split.data)
            // var parsed = hfm.parse([split.data, '---'].join('\n'))
            // console.log('-----> split parsed', parsed)
            return res.done(addIsDraft(post))
        }

    })

    use('post/update/:id', function(req, res, next) {
        let id = req.params.id
        if (!req.body) {
            return res.send(400, 'No post body given')
        }

        update(id, req.body, function (err, post) {
            if (err) {
                return res.send(400, err)
            }
            post = _.cloneDeep(post)
            res.done({
                post: addIsDraft(post),
                tagsCategoriesAndMetadata: tagsCategoriesAndMetadata()
            })
        }, hexo)
    })

    use('postMeta/:id', function (req, res, next) {
        var id = req.params.id
        if (req.method === 'GET') {
            console.log("Searching for post with id:", id);
            id = utils.base64Decode(id)
            // 使用findOne代替filter+[0]，避免undefined问题
            var post = hexo.model('Post').filter(post => {
                const permalink = post.permalink;
                // console.log("Checking slug:", permalink, "Match result:", id === permalink);
                return id === permalink;
            }).data[0];

            // 如果没找到匹配的文章
            if (!post) {
                console.log("No post found with slug:", id);
                // 列出所有可用的slug供调试
                console.log("Available slugs:", hexo.model('Post').toArray().map(p => p.slug).join(', '));
                next();
                return;
            }
            var split = hfm.split(post.raw)
            // console.log('-----> split data', split.data)
            var parsed = hfm.parse([split.data, '---'].join('\n'))
            const { title, author, date, _content, ...rest } = parsed
            if (typeof rest['categories'] === 'string') {
                rest['categories'] = [rest['categories']]
            }
            if (typeof rest['tags'] === 'string') {
                rest['tags'] = [rest['tags']]
            }
            if (!rest.tags) {
                rest.tags = []
            }
            if (!rest.categories) {
                rest.categories = []
            }
            const ans = {}
            ans.categories = rest.categories
            ans.tags = rest.tags
            const fm = {}
            Object.keys(rest).forEach((name) => {
                if (name == 'categories' || name == 'tags') {
                    return
                }
                fm[name] = rest[name]
            })
            ans.frontMatter = fm
            return res.done(ans)
        }
    })

    use('tags-categories-and-metadata', function (req, res, next) {
        return res.done(tagsCategoriesAndMetadata())
    })

    use('settings/list', function (req, res, next) {
        res.done(getSettings())
    })
    // use('images/upload', async function (req, res, next) {
    //     if (req.method !== 'POST') return next();
    //     if (!req.body) {
    //         return res.send(400, 'No post body given');
    //     }
    //     if (!req.body.data) {
    //         return res.send(400, 'No data given');
    //     }

    //     const imagePath = '/images';
    //     let imagePrefix = 'pasted-';
    //     if (req.body.filename) {
    //         imagePrefix = req.body.filename
    //     }

    //     // function generateShortId() {
    //     //     const uuid = uuidv4().replace(/-/g, ''); // 生成 UUID 并去除分隔符
    //     //     return uuid.substring(0, 10); // 截取前10个字符
    //     // }

    //     const msg = 'upload successful';
    //     // const shortId = generateShortId(); // 生成短唯一标识符
    //     const filename = `${imagePrefix}-${uuidv4()}-${Date.now()}.png`;

    //     const outpath = path.join(hexo.source_dir, imagePath, filename);

    //     // Ensure directory exists
    //     if (!fs.existsSync(path.dirname(outpath))) {
    //         fs.mkdirsSync(path.dirname(outpath));
    //     }

    //     try {
    //         // Strip out the data prefix for base64 encoded images
    //         const dataURI = req.body.data.replace(/^data:image\/\w+;base64,/, '');
    //         const buf = Buffer.from(dataURI, 'base64');

    //         console.log(`Saving image to ${outpath}`);

    //         // Asynchronous write with a promise
    //         await fs.writeFile(outpath, buf);

    //         const encodedFilename = encodeURIComponent(filename)
    //         // Generate the correct src path
    //         const imageSrc = `${imagePath}/${encodedFilename}`;


    //         // Process the source to ensure it is correctly added to Hexo's file structure
    //         // await hexo.source.process();
    //         // throw new Error('hexo.source.process() should have resolved the promise');
    //         res.done({
    //             src: imageSrc,
    //             msg: msg
    //         });
    //     } catch (error) {
    //         hexo.log.e(`Error saving image: ${error.message}`);
    //         return res.send(500, 'Failed to save image');
    //     }
    // });


    // 新增接口：更新文章的frontMatter
    use('updateFrontMatter', function (req, res, next) {
        if (req.method !== 'POST') return next();
        if (!req.body) {
            return res.send(500, 'No post body given');
        }
        if (!req.body.permalink) {
            return res.send(500, 'No permalink given');
        }
        if (!req.body.key || !req.body.value) {
            return res.send(500, 'Key or value missing');
        }

        const permalink = req.body.permalink;
        const key = req.body.key;
        const value = req.body.value;

        // 构建更新对象
        const frontMatterUpdate = {};
        frontMatterUpdate[key] = value;

        // 使用update函数更新文章
        update(permalink, { frontMatter: frontMatterUpdate }, function (err, post) {
            if (err) {
                return res.send(400, err);
            }
            post = _.cloneDeep(post);
            res.done(addIsDraft(post));
        }, hexo);
    });



}

# Hexo Pro

[![GitHub license](https://img.shields.io/github/license/wuzheng228/hexo-pro)](https://github.com/wuzheng228/hexo-pro/blob/main/LICENSE)
[![Version](https://img.shields.io/badge/version-1.3.0-blue)](https://github.com/wuzheng228/hexo-pro/releases)
[![npm downloads](https://img.shields.io/npm/dm/hexo-pro)](https://www.npmjs.com/package/hexo-pro)
[![GitHub stars](https://img.shields.io/github/stars/wuzheng228/hexo-pro)](https://github.com/wuzheng228/hexo-pro/stargazers)

> 现代化 Hexo 博客后台管理系统，助力高效内容创作与管理

---

## 🏆 项目简介

Hexo Pro 是专为 **Hexo** 静态博客框架打造的后台管理系统插件，旨在为博客作者和开发者提供更强大、更便捷的内容管理体验。

项目愿景/定位：

Hexo Pro为Hexo用户提供专业级内容管理体验，节省您90%的内容维护时间！

相关项目：
- [Hexo Pro Client](https://github.com/wuzheng228/hexo-pro-client) - Hexo Pro 的前端实现，基于 React 开发的现代化管理界面
- [Hexo Pro Desktop](https://github.com/wuzheng228/hexo-pro-desktop) - 基于 Electron 的桌面客户端，支持多项目管理与本地增强体验

---

## ✨ 核心优势

* 🚀 极致易用：界面友好，操作直观，零学习成本上手
* 🌗 多主题支持：一键切换暗黑/明亮模式，适配不同使用场景
* 📱 移动端适配：响应式设计，手机、平板、PC 全面支持
* 🔒 安全可靠：支持多用户权限管理，数据安全有保障
* ⚡ 高效集成：与 Hexo 生态无缝对接，支持主流插件与主题
* 🖥️ 桌面端增强：支持多项目切换、智能认证、原生菜单、离线管理等桌面专属功能

---

## 🎯 功能亮点

* 文章管理：创建、编辑、删除文章，支持 Front-matter 可视化编辑
* 页面管理：轻松管理静态页面
* 图床集成：支持图片粘贴上传与批量管理
* 配置管理：可视化编辑 Hexo 配置文件
* 全局搜索：基于 Fuse.js 的极速全文检索
* 一键部署：多种部署方式，轻松上线
* 国际化支持：多语言界面，全球用户友好
* 桌面端专属：多项目管理、自动认证、原生菜单、离线支持、智能端口管理等
* 更多功能：……

---

## 📦 子项目结构

本项目包含以下子模块：

```
parent-directory/
├── hexo-pro/           # 本插件（后端核心）
├── hexo-pro-client/    # 前端管理界面（React）
└── hexo-pro-desktop/   # 桌面客户端（Electron）
```

* **hexo-pro**：Hexo 插件，提供 API 和服务端逻辑
* **hexo-pro-client**：现代化 Web 管理界面
* **hexo-pro-desktop**：桌面客户端，集成 hexo-pro-core，支持多项目与本地增强体验

---

## 🚀 快速开始

### 1. 作为 Hexo 插件使用

#### 前置要求

* Node.js 16+
* Hexo 7.x

#### 安装步骤

```bash
# 1. 安装 Hexo Pro 插件
npm install --save hexo-pro

# 2. 启动 Hexo 服务器
hexo server -d

# 3. 访问后台管理页面
open http://localhost:4000/pro/
```

### 2. 使用桌面客户端

#### 系统要求

* Windows 10+ / macOS 10.14+ / Ubuntu 18.04+
* Node.js 16+

#### 安装与启动

直接下载 **[Releases](https://github.com/wuzheng228/hexo-pro/releases)** 预构建版本。

#### 使用说明

* 首次启动选择 Hexo 博客项目目录，自动启动 Hexo Pro 服务
* 支持多项目切换、自动认证、原生菜单、快捷键等桌面增强体验
* 详细功能见 **桌面端 README**

---

## 📸 界面预览

<div align="center">

**登录页** | **文章列表** | **编辑器**
:---: | :---: | :---:
<img src="docs/login-page.png" width="250"> | <img src="docs/posts-page.png" width="250"> | <img src="docs/editor-page.png" width="250">

**主页** | **图床管理** | **配置管理**
:---: | :---: | :---:
<img src="docs/home-page.png" width="250"> | <img src="docs/image-manager-page.png" width="250"> | <img src="docs/config-manager-page.png" width="250">

**全局搜索** | **部署**
:---: | :---:
<img src="docs/global-search-page.png" width="250"> | <img src="docs/deploy-page.png" width="250">

</div>

---

## 📅 更新日志

* 2025-01-XX v2.0.0

✅ **🔧 FrontMatter 布尔值修复** - 修复了 frontMatter 中布尔值的展示和设置问题，确保正确处理 true/false 值

✅ **🔌 智能插件加载** - 桌面端优化插件加载逻辑，可自动加载已有项目下 node_modules 中所有可用的 Hexo 插件

✅ **🌐 灵活链接跳转** - 桌面端跳转链接默认指向 localhost:4000，支持通过设置自定义配置目标地址

✅ **✏️ 编辑器默认模式** - 新增编辑器默认模式配置，可根据个人喜好设置编辑器的默认工作模式

✅ **🖼️ 封面隐藏控制** - 新增封面隐藏设置选项，开启后可以隐藏文章封面图片显示

✅ **⚡ 快速部署模式** - 新增部署跳过静态文件生成配置，开启后可直接推送到仓库，提升部署效率

* 2025-06-07 v1.3.0

✅ 新增桌面端（hexo-pro-desktop）子项目，支持多项目管理与本地增强体验

✅ 优化核心 API 结构，提升桌面端与 Web 端协同体验

* 2025-05-10 v1.2.0

✅ 新增图床管理功能

✅ 新增yaml配置管理

✅ 新增设置和主页功能

* 2024-08-29 v1.1.16

🔧 优化编辑器体验

🌗 改进暗黑模式

🔍 增强全局搜索功能

---

## 🤝 参与贡献

欢迎通过以下方式参与项目：

* 提交 Issues 报告问题或建议
* 提交 Pull Request 贡献代码
* 加入 QQ 群交流：1009585669

<img src="docs/qq-group.png" width="150">

---

## 📄 许可证

MIT © wuzheng

---

## ☕️ 打赏支持

如果你觉得本项目不错，可以请我喝杯咖啡☕️，支持项目持续优化！

<img src="docs/donate_alipay.jpg" width="150" alt="打赏二维码">
<img src="docs/donate_wc.jpg" width="150" alt="打赏二维码">

---

## 🙏 感谢捐助者

感谢以下用户对项目的支持,排名不分先后，您的捐助是我们持续开发的动力！

<div align="center">

<table>
<tr>
<td align="center">
<img src="docs/sponsors/sponsor_vk.jpg" width="60" height="60" style="border-radius: 50%;" alt="捐助者头像"><br>
<sub><b>v快</b></sub>
</td>
<td align="center">
<img src="docs/sponsors/sponsor_empty.jpg" width="60" height="60" style="border-radius: 50%;" alt="捐助者头像"><br>
<sub><b>💝 神秘支持者</b></sub>
</td>
<td align="center">
<img src="docs/sponsors/sponsor_crosery.png" width="60" height="60" style="border-radius: 50%;" alt="捐助者头像"><br>
<sub><b>Crosery</b></sub>
</td>
</table>

</div>

> 💝 想成为捐助者？扫描上方二维码支持项目，并联系我们添加您的头像！

---

如果本项目对您有帮助，欢迎：

⭐ 给个Star支持

📢 分享给更多Hexo用户

💬 提出宝贵建议

您的支持会让Hexo生态更强大！

## 📦 技术栈
- **后端**：Node.js + Express
- **数据库**：NeDB (嵌入式数据库)
- **前端**：React (hexo-pro-client)
- **桌面端**：Electron (hexo-pro-desktop)
- **核心依赖**：Hexo 7.x, Fuse.js, Multer 等
const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const jwt = require('jsonwebtoken');

module.exports = function(app, hexo, use, db) {
  const { userDb, settingsDb } = db;

  // 添加检查是否首次使用的API
  use('settings/check-first-use', function(req, res) {
    userDb.count({}, (err, count) => {
      if (err) {
        return res.done({ code: 500, msg: '检查系统状态失败' });
      }
      
      // 如果没有用户，直接返回首次使用
      if (count === 0) {
        return res.done({
          code: 0,
          data: {
            isFirstUse: true,
            hasTemporaryUser: false
          }
        });
      }
      
      // 如果有用户，检查是否只有临时用户
      userDb.find({}, (err, users) => {
        if (err) {
          return res.done({ code: 500, msg: '检查系统状态失败' });
        }
        
        // 检查是否所有用户都是临时用户
        const hasRealUser = users.some(user => !user.isTemporary);
        const hasTemporaryUser = users.some(user => user.isTemporary);
        
        if (!hasRealUser && hasTemporaryUser) {
          // 只有临时用户，仍然算是首次使用
          return res.done({
            code: 0,
            data: {
              isFirstUse: true,
              hasTemporaryUser: true
            }
          });
        } else if (hasRealUser) {
          // 有正式用户，不是首次使用
          return res.done({
            code: 0,
            data: {
              isFirstUse: false,
              hasTemporaryUser: hasTemporaryUser
            }
          });
        } else {
          // 理论上不会到达这里，但为了安全起见
          return res.done({
            code: 0,
            data: {
              isFirstUse: true,
              hasTemporaryUser: false
            }
          });
        }
      });
    });
  });

  // 添加首次使用注册API
  use('settings/register', function(req, res) {
    // 检查是否已有用户
    userDb.count({}, (err, count) => {
      if (err) {
        return res.done({ code: 500, msg: '检查系统状态失败' });
      }
      
      // 如果没有用户，直接允许注册
      if (count === 0) {
        proceedWithRegistration();
      } else {
        // 如果有用户，检查是否只有临时用户
        userDb.find({}, (err, users) => {
          if (err) {
            return res.done({ code: 500, msg: '检查系统状态失败' });
          }
          
          const hasRealUser = users.some(user => !user.isTemporary);
          const tempUsers = users.filter(user => user.isTemporary);
          
          if (hasRealUser) {
            // 已有正式用户，不允许注册
            return res.done({ code: 403, msg: '系统已初始化，不能再次注册' });
          } else if (tempUsers.length > 0) {
            // 只有临时用户，可以注册正式用户，但需要先清理临时用户
            cleanupTemporaryUsersAndProceed(tempUsers);
          } else {
            // 理论上不会到达这里，但为了安全起见，允许注册
            proceedWithRegistration();
          }
        });
      }
      
      // 清理临时用户并继续注册
      function cleanupTemporaryUsersAndProceed(tempUsers) {
        console.log('[Hexo Pro]: 清理临时用户，准备注册正式用户');
        
        // 删除所有临时用户
        const tempUsernames = tempUsers.map(user => user.username);
        
        // 删除临时用户记录
        userDb.remove({ isTemporary: true }, { multi: true }, (err) => {
          if (err) {
            console.error('[Hexo Pro]: 删除临时用户失败:', err);
            return res.done({ code: 500, msg: '清理临时用户失败' });
          }
          
          // 删除临时用户的设置
          settingsDb.remove({ username: { $in: tempUsernames } }, { multi: true }, (err) => {
            if (err) {
              console.error('[Hexo Pro]: 删除临时用户设置失败:', err);
              // 不阻止注册流程，继续执行
            }
            
            console.log('[Hexo Pro]: 临时用户清理完成，开始正式注册');
            proceedWithRegistration();
          });
        });
      }
      
      // 执行注册流程
      function proceedWithRegistration() {
        const { username, password, confirmPassword, avatar } = req.body;
        
        // 验证输入
        if (!username || !password) {
          return res.done({ code: 400, msg: '用户名和密码不能为空' });
        }
        
        if (password !== confirmPassword) {
          return res.done({ code: 400, msg: '两次输入的密码不一致' });
        }
        
        // 创建新用户（正式用户，不是临时用户）
        const newUser = {
          username,
          password,
          avatar: avatar || '',
          isTemporary: false, // 明确标记为正式用户
          createdAt: new Date(),
          updatedAt: new Date()
        };
        
        userDb.insert(newUser, (err) => {
          if (err) {
            return res.done({ code: 500, msg: '创建用户失败' });
          }
          
          // 创建默认设置
          const newSettings = {
            username,
            menuCollapsed: false,
            createdAt: new Date(),
            updatedAt: new Date()
          };
          
          settingsDb.insert(newSettings, (err) => {
            if (err) {
              return res.done({ code: 500, msg: '创建设置失败' });
            }
            
            // 确保系统设置存在，生成或更新JWT密钥
            ensureSystemSettings((jwtSecret) => {
              // 返回成功信息和JWT令牌
              const jwt = require('jsonwebtoken');
              const token = jwt.sign({ username }, jwtSecret, { expiresIn: '7d' });
              
              // 更新全局的needLogin状态为true（因为现在有正式用户了）
              global.actualNeedLogin = true;
              console.log('[Hexo Pro]: 正式用户注册成功，已更新登录验证状态为true');
              
              res.done({
                code: 0,
                msg: '注册成功',
                data: {
                  token,
                  username,
                  avatar: newUser.avatar
                }
              });
            });
          });
        });
      }
      
      // 确保系统设置存在的辅助函数
      function ensureSystemSettings(callback) {
        settingsDb.findOne({ type: 'system' }, (err, systemSettings) => {
          if (err) {
            return res.done({ code: 500, msg: '获取系统设置失败' });
          }
          
          if (systemSettings && systemSettings.jwtSecret) {
            // 使用现有的JWT密钥
            global.jwtSecret = systemSettings.jwtSecret;
            callback(systemSettings.jwtSecret);
          } else {
            // 生成新的JWT密钥
            const jwtSecret = require('crypto').randomBytes(64).toString('hex');
            global.jwtSecret = jwtSecret;
            
            const settingData = {
              type: 'system',
              jwtSecret: jwtSecret,
              createdAt: new Date(),
              updatedAt: new Date()
            };
            
            if (systemSettings) {
              // 更新现有设置
              settingsDb.update({ type: 'system' }, { $set: settingData }, {}, (err) => {
                if (err) {
                  return res.done({ code: 500, msg: '更新系统设置失败' });
                }
                callback(jwtSecret);
              });
            } else {
              // 创建新设置
              settingsDb.insert(settingData, (err) => {
                if (err) {
                  return res.done({ code: 500, msg: '创建系统设置失败' });
                }
                callback(jwtSecret);
              });
            }
          }
        });
      }
    });
  });

  // 添加跳过设置API（用于首次使用时的免密登录）
  use('settings/skip-setup', function(req, res) {
    // 检查是否已有用户
    userDb.count({}, (err, count) => {
      if (err) {
        return res.done({ code: 500, msg: '检查系统状态失败' });
      }
      
      // 如果没有用户，创建临时用户
      if (count === 0) {
        createTemporaryUser();
      } else {
        // 如果有用户，检查是否存在临时用户
        userDb.find({}, (err, users) => {
          if (err) {
            return res.done({ code: 500, msg: '检查系统状态失败' });
          }
          
          const hasRealUser = users.some(user => !user.isTemporary);
          const tempUser = users.find(user => user.isTemporary);
          
          if (hasRealUser) {
            // 已有正式用户，不允许跳过设置
            return res.done({ code: 403, msg: '系统已初始化，不能跳过设置' });
          } else if (tempUser) {
            // 存在临时用户，为其生成新token
            generateTokenForUser(tempUser.username);
          } else {
            // 理论上不会到达这里，但为了安全起见，创建临时用户
            createTemporaryUser();
          }
        });
      }
      
      // 创建临时用户的函数
      function createTemporaryUser() {
        const tempUsername = 'temp_user_' + Date.now();
        const tempUser = {
          username: tempUsername,
          password: null, // 没有密码，表示临时用户
          avatar: '',
          isTemporary: true, // 标记为临时用户
          createdAt: new Date(),
          updatedAt: new Date()
        };
        
        userDb.insert(tempUser, (err) => {
          if (err) {
            return res.done({ code: 500, msg: '创建临时用户失败' });
          }
          
          // 创建默认设置
          const newSettings = {
            username: tempUsername,
            menuCollapsed: false,
            createdAt: new Date(),
            updatedAt: new Date()
          };
          
          settingsDb.insert(newSettings, (err) => {
            if (err) {
              return res.done({ code: 500, msg: '创建设置失败' });
            }
            
            ensureJwtSecretAndGenerateToken(tempUsername);
          });
        });
      }
      
      // 为现有用户生成token的函数
      function generateTokenForUser(username) {
        ensureJwtSecretAndGenerateToken(username);
      }
      
      // 确保JWT密钥存在并生成token的函数
      function ensureJwtSecretAndGenerateToken(username) {
        // 检查是否存在JWT密钥
        settingsDb.findOne({ type: 'system' }, (err, systemSettings) => {
          if (err) {
            return res.done({ code: 500, msg: '获取系统设置失败' });
          }
          
          let jwtSecret = systemSettings ? systemSettings.jwtSecret : null;
          
          if (!jwtSecret) {
            // 创建JWT密钥
            jwtSecret = require('crypto').randomBytes(64).toString('hex');
            global.jwtSecret = jwtSecret;
            
            const settingData = {
              type: 'system',
              jwtSecret: jwtSecret,
              createdAt: new Date(),
              updatedAt: new Date()
            };
            
            if (systemSettings) {
              // 更新现有设置
              settingsDb.update({ type: 'system' }, { $set: settingData }, {}, (err) => {
                if (err) {
                  return res.done({ code: 500, msg: '更新系统设置失败' });
                }
                generateAndReturnToken(username, jwtSecret);
              });
            } else {
              // 创建新设置
              settingsDb.insert(settingData, (err) => {
                if (err) {
                  return res.done({ code: 500, msg: '创建系统设置失败' });
                }
                generateAndReturnToken(username, jwtSecret);
              });
            }
          } else {
            // 使用现有的JWT密钥
            global.jwtSecret = jwtSecret;
            generateAndReturnToken(username, jwtSecret);
          }
        });
      }
      
      // 生成并返回token的函数
      function generateAndReturnToken(username, jwtSecret) {
        const jwt = require('jsonwebtoken');
        const token = jwt.sign({ username: username }, jwtSecret, { expiresIn: '30d' });
        
        // 暂时不更新全局的needLogin状态，保持为false以便后续可以设置正式账号
        global.actualNeedLogin = false;
        console.log('[Hexo Pro]: 用户选择跳过设置，使用临时账号:', username);
        
        res.done({
          code: 0,
          msg: '已跳过设置，可稍后在设置页面配置账号密码',
          data: {
            token,
            username: username,
            isTemporary: true
          }
        });
      }
    });
  });

  // 获取当前用户设置
  use('settings', function(req, res) {
    // 修改这里：使用 req.auth
    let username = req.auth ? req.auth.username : null;
  
     // 首先尝试从req.auth获取用户名
    if (req.auth && req.auth.username) {
        username = req.auth.username;
        // console.log('从req.auth获取到用户名:', username);
    } 
    // 如果req.auth不存在，尝试手动解析token
    else if (req.headers.authorization && req.headers.authorization.startsWith('Bearer ')) {
        try {
            const token = req.headers.authorization.split(' ')[1];
            console.log('尝试手动解析token:', token);
            
            if (token && global.jwtSecret) {
                const decoded = jwt.verify(token, global.jwtSecret);
                console.log('手动解析token结果:', decoded);
                
                if (decoded && decoded.username) {
                    username = decoded.username;
                    console.log('从token中获取到用户名:', username);
                }
            }
        } catch (error) {
            console.error('解析token失败:', error.message);
        }
    }
    
    if (!username) {
      return res.done({ code: 401, msg: '未授权' });
    }

    userDb.findOne({ username }, (err, user) => {
      if (err) {
        return res.done({ code: 500, msg: '获取用户信息失败' });
      }

      if (!user) {
        return res.done({ code: 404, msg: '用户不存在' });
      }

      // 获取用户设置
      settingsDb.findOne({ username }, (err, settings) => {
        if (err) {
          return res.done({ code: 500, msg: '获取设置失败' });
        }

        // 返回用户信息和设置
        res.done({
          code: 0,
          data: {
            username: user.username,
            avatar: user.avatar || '',
            menuCollapsed: settings ? settings.menuCollapsed : false
          }
        });
      });
    });
  });

  // 更新用户设置
  use('settings/update', function(req, res) {
    // 修改这里：使用 req.auth
    let currentUsername = req.auth ? req.auth.username : null;
    
    

    if (req.auth && req.auth.username) {
      currentUsername = req.auth.username;
    } 
    // 如果req.auth不存在，尝试手动解析token
    else if (req.headers.authorization && req.headers.authorization.startsWith('Bearer ')) {
        try {
            const token = req.headers.authorization.split(' ')[1];
            console.log('尝试手动解析token:', token);
            
            if (token && global.jwtSecret) {
                const decoded = jwt.verify(token, global.jwtSecret);
                console.log('手动解析token结果:', decoded);
                
                if (decoded && decoded.username) {
                    currentUsername = decoded.username;
                    console.log('从token中获取到用户名:', currentUsername);
                }
            }
        } catch (error) {
            console.error('解析token失败:', error.message);
        }
    }

    if (!currentUsername) {
      return res.done({ code: 401, msg: '未授权' });
    }

    const { username: newUsername, avatar, password, confirmPassword, menuCollapsed } = req.body;

    // 验证密码
    if (password && password !== confirmPassword) {
      return res.done({ code: 400, msg: '两次输入的密码不一致' });
    }

    // 检查新用户名是否与其他用户冲突（如果用户名发生了变化）
    if (newUsername && newUsername !== currentUsername) {
      userDb.findOne({ username: newUsername }, (err, existingUser) => {
        if (err) {
          return res.done({ code: 500, msg: '检查用户名失败' });
        }
        
        if (existingUser) {
          return res.done({ code: 400, msg: '用户名已存在' });
        }
        
        // 用户名不冲突，继续更新流程
        proceedWithUpdate();
      });
    } else {
      // 用户名没有变化，直接更新
      proceedWithUpdate();
    }

    function proceedWithUpdate() {
      // 更新用户信息
      userDb.findOne({ username: currentUsername }, (err, user) => {
        if (err || !user) {
          return res.done({ code: 500, msg: '获取用户信息失败' });
        }

        const updateData = {};
        
        // 只更新提供的字段
        if (newUsername !== undefined && newUsername !== currentUsername) {
          updateData.username = newUsername;
        }
        
        if (avatar !== undefined) {
          updateData.avatar = avatar;
        }
        
        if (password) {
          updateData.password = password;
        }

        updateData.updatedAt = new Date();

        userDb.update({ username: currentUsername }, { $set: updateData }, { upsert: false }, (err) => {
          if (err) {
            return res.done({ code: 500, msg: '更新用户信息失败' });
          }

          const finalUsername = newUsername || currentUsername;

          // 更新设置
          settingsDb.findOne({ username: currentUsername }, (err, settings) => {
            if (err) {
              return res.done({ code: 500, msg: '获取设置失败' });
            }

            const settingsUpdateData = {
              username: finalUsername, // 如果用户名变了，也要更新设置中的用户名
              menuCollapsed,
              updatedAt: new Date()
            };

            if (settings) {
              // 更新现有设置
              settingsDb.update(
                { username: currentUsername }, 
                { $set: settingsUpdateData }, 
                {}, 
                (err) => {
                  if (err) {
                    return res.done({ code: 500, msg: '更新设置失败' });
                  }
                  
                  handlePostUpdateActions(finalUsername, password);
                }
              );
            } else {
              // 创建新设置
              const newSettings = {
                ...settingsUpdateData,
                createdAt: new Date()
              };
              
              settingsDb.insert(newSettings, (err) => {
                if (err) {
                  return res.done({ code: 500, msg: '创建设置失败' });
                }
                
                handlePostUpdateActions(finalUsername, password);
              });
            }
          });
        });
      });
    }

    function handlePostUpdateActions(finalUsername, password) {
      // 如果更新了密码，同时更新配置文件
      if (password) {
        updateConfigFile(finalUsername, password);
      }
      
      // 如果用户名发生了变化，需要生成新的token
      if (newUsername && newUsername !== currentUsername) {
        const jwt = require('jsonwebtoken');
        const newToken = jwt.sign({ username: finalUsername }, global.jwtSecret, { expiresIn: '7d' });
        
        res.done({ 
          code: 0, 
          msg: '设置已更新',
          data: {
            token: newToken, // 返回新的token
            username: finalUsername
          }
        });
      } else {
        res.done({ code: 0, msg: '设置已更新' });
      }
    }
  });

  // 上传头像
  use('settings/upload-avatar', function(req, res) {
    // 修改这里：使用 req.auth
    const username = req.auth ? req.auth.username : null;
    
    if (!username) {
      return res.done({ code: 401, msg: '未授权' });
    }

    const { data, filename } = req.body;
    
    if (!data || !filename) {
      return res.done({ code: 400, msg: '缺少必要参数' });
    }

    // 使用图床API上传头像
    // 直接调用 image_api.js 中的上传图片功能
    // 将头像上传到图床根目录
    
    // 处理Base64图片数据
    const matches = data.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/);
    if (!matches || matches.length !== 3) {
      return res.done({ code: 400, msg: '无效的图片数据' });
    }
    
    const type = matches[1];
    const imageBuffer = Buffer.from(matches[2], 'base64');
    
    // 生成文件名 - 使用avatar_前缀以便识别
    const ext = path.extname(filename);
    const newFilename = `avatar_${username}_${Date.now()}${ext}`;
    
    // 确定保存路径 - 使用图床根目录
    const imagesDir = path.join(hexo.source_dir, 'images');
    
    // 确保目录存在
    fs.ensureDirSync(imagesDir);
    
    const filePath = path.join(imagesDir, newFilename);
    
    // 检查文件是否已存在
    if (fs.existsSync(filePath)) {
      // 如果文件已存在，添加时间戳
      const nameWithoutExt = newFilename.substring(0, newFilename.lastIndexOf('.'));
      const extension = newFilename.substring(newFilename.lastIndexOf('.'));
      newFilename = `${nameWithoutExt}_${Date.now()}${extension}`;
    }
    
    const finalFilePath = path.join(imagesDir, newFilename);
    
    try {
      fs.writeFileSync(finalFilePath, imageBuffer);
      
      // 返回图片URL - 使用图床的URL格式
      const relativePath = `images/${newFilename}`;
      const avatarUrl = hexo.config.url + `/${relativePath}`;
      
      // 更新用户头像URL
      userDb.update({ username }, { $set: { avatar: avatarUrl, updatedAt: new Date() } }, {}, (err) => {
        if (err) {
          return res.done({ code: 500, msg: '更新头像信息失败' });
        }
        
        res.done({ 
          code: 0, 
          msg: '头像上传成功', 
          data: { 
            url: avatarUrl,
            path: relativePath,
            name: newFilename
          } 
        });
      });
    } catch (err) {
      console.error('保存头像失败:', err);
      res.done({ code: 500, msg: '保存头像失败: ' + err.message });
    }
  });

  // 更新配置文件中的用户名和密码
  function updateConfigFile(username, password) {
    try {
      // 更新数据库中的用户信息
      userDb.update(
        { username }, 
        { $set: { password, updatedAt: new Date() } }, 
        {}, 
        (err) => {
          if (err) {
            console.error('[Hexo Pro]: 更新用户密码失败', err);
            return;
          }
          
          console.log('[Hexo Pro]: 已更新数据库中的用户密码');
          
          // 更新或创建系统设置中的 JWT secret
          settingsDb.findOne({ type: 'system' }, (err, settings) => {
            if (err) {
              console.error('[Hexo Pro]: 获取系统设置失败', err);
              return;
            }
            
            const jwtSecret = require('crypto').randomBytes(64).toString('hex');
            
            if (settings) {
              // 更新现有设置
              settingsDb.update(
                { type: 'system' }, 
                { $set: { jwtSecret, updatedAt: new Date() } }, 
                {}, 
                (err) => {
                  if (err) {
                    console.error('[Hexo Pro]: 更新 JWT 密钥失败', err);
                  } else {
                    console.log('[Hexo Pro]: 已更新 JWT 密钥');
                  }
                }
              );
            } else {
              // 创建新设置
              settingsDb.insert({
                type: 'system',
                jwtSecret,
                createdAt: new Date(),
                updatedAt: new Date()
              }, (err) => {
                if (err) {
                  console.error('[Hexo Pro]: 创建系统设置失败', err);
                } else {
                  console.log('[Hexo Pro]: 已创建系统设置并保存 JWT 密钥');
                }
              });
            }
          });
        }
      );
      
      // 注意：不再更新 _config.yml 文件
      console.log('[Hexo Pro]: 用户信息现在仅保存在数据库中，不再更新配置文件');
      
    } catch (error) {
      console.error('[Hexo Pro]: 更新用户信息失败', error);
      throw error; // 抛出异常以便上层函数知道更新失败
    }
  }
};var path = require('path'),
    moment = require('moment'),
    hfm = require('hexo-front-matter'),
    fs = require('hexo-fs'),
    extend = require('extend');
const utils = require('./utils');
//  yfm = util.yfm,
//  escape = util.escape;


/**
 * Updates a post.
 *
 * @method update
 * @param {str} model the type of model being updated
 * @param {Object} post a post model
 * @param {Object} update attributes to update
 * @param {Function} callback
 */

module.exports = function (model, unimark, update, callback, hexo) {
    unimark = utils.base64Decode(unimark)
    const newFrontMatter = update.frontMatter
    if (newFrontMatter) {
        delete update.frontMatter
    }

    var post = hexo.model(model).filter(post => {

        return unimark === post.permalink;
    }).data[0];
    if (!post) {
        return callback('Post not found');
    }
    var config = hexo.config,
        layout = post.layout = (post.layout || config.default_layout).toLowerCase(),
        // 添加时间戳确保唯一性
        slug = post.slug = `${hfm.escape(post.slug || post.title, config.filename_case)}-${Date.now()}`,
        date = post.date = post.date ? moment(post.date) : moment();
    // console.log("post.raw:", post.raw)
    var split = hfm.split(post.raw),
        frontMatter = split.data
    compiled = hfm.parse([frontMatter, '---', split.content].join('\n'));

    var preservedKeys = ['title', 'date', 'tags', 'categories', '_content', 'author'];
    Object.keys(hexo.config.metadata || {}).forEach(function (key) {
        preservedKeys.push(key);
    });
    var prev_full = post.full_source,
        full_source = prev_full;
    if (update.source && update.source !== post.source) {
        // post.full_source only readable ~ see: /hexo/lib/models/post.js
        full_source = hexo.source_dir + update.source
    }

    preservedKeys.forEach(function (attr) {
        if (attr in update) {
            compiled[attr] = update[attr]
        }
    });
    compiled.date = moment(compiled.date).toDate()

    if (newFrontMatter) {
        Object.keys(newFrontMatter).forEach(name => {
            compiled[name] = newFrontMatter[name]
        })
        Object.keys(compiled).forEach(name => {
            if (['title', 'date', 'tags', 'categories', '_content', 'author'].includes(name)) {
                return
            }
            if (Object.keys(newFrontMatter).includes(name)) {
                return
            }
            // console.log('delete', name)
            delete compiled[name]
        })
    }

    delete update._content
    var raw = hfm.stringify(compiled, { prefixSeparator: true });
    update.raw = raw
    update.updated = moment()
    update.slug = slug

    // tags and cats are only getters now. ~ see: /hexo/lib/models/post.js
    if (typeof update.tags !== 'undefined') {
        post.setTags(update.tags)
        delete update.tags
    }
    if (typeof update.categories !== 'undefined') {
        post.setCategories(update.categories)
        delete update.categories
    }

    extend(post, update)

    post.save().then(async () => {
        fs.writeFileSync(full_source, raw);
        hexo.log.info('文章保存成功！');
        await hexo.source.process().then(function () {
            //      console.log(post.full_source, post.source)
            callback(null, hexo.model(model).filter(post => {
                const permalink = post.permalink;
                return unimark === permalink;
            }).data[0]);
        });
    }).catch(err => {
        hexo.log.error('保存失败:', err);
        callback(err, null);
    });


}


module.exports = {
    base64Decode: function base64Decode(base64) {
        return decodeURIComponent(escape(atob(base64)));
    }
}var path = require('path');
var fs = require('hexo-fs');
var fse = require('fs-extra');
var yml = require('js-yaml');
const { v4: uuidv4 } = require('uuid');
// 新增：引入 exec 用于执行命令行
const { exec } = require('child_process');

module.exports = function (app, hexo, use) {
  // 获取 YAML 文件列表
  use('yaml/list', function (req, res) {
    const page = parseInt(req.query.page) || 1;
    const pageSize = parseInt(req.query.pageSize) || 10;

    // 获取所有 YAML 文件
    const yamlFiles = [];
    const rootDir = hexo.base_dir;

    // 递归查找所有 YAML 文件
    function findYamlFiles(dir, relativePath = '') {
      const files = fs.readdirSync(dir);

      for (const file of files) {
        const filePath = path.join(dir, file);
        const relPath = path.join(relativePath, file).replace(/\\/g, '/');
        const stat = fs.statSync(filePath);

        if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
          findYamlFiles(filePath, relPath);
        } else if (
          (file.endsWith('.yml') || file.endsWith('.yaml')) &&
          !file.startsWith('.')
        ) {
          const content = fse.readFileSync(filePath, 'utf-8');
          yamlFiles.push({
            name: file,
            path: relPath,
            content: content,
            lastModified: new Date(stat.mtime).toLocaleString()
          });
        }
      }
    }

    findYamlFiles(rootDir);

    // 分页
    const total = yamlFiles.length;
    const startIndex = (page - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    const paginatedFiles = yamlFiles.slice(startIndex, endIndex);

    res.done({
      files: paginatedFiles,
      total: total,
      page: page,
      pageSize: pageSize
    });
  });

  // 创建 YAML 文件
  use('yaml/create', function (req, res) {
    const { name, path: filePath, content } = req.body;

    if (!name) {
      return res.status(400).json({ error: '文件名不能为空' });
    }

    const fullPath = path.join(hexo.base_dir, filePath || '', name);

    // 检查文件是否已存在
    if (fs.existsSync(fullPath)) {
      return res.status(400).json({ error: '文件已存在' });
    }

    // 创建目录（如果不存在）
    if (filePath) {
      const dirPath = path.join(hexo.base_dir, filePath);
      fse.ensureDirSync(dirPath);
    }

    // 写入文件
    fs.writeFileSync(fullPath, content || '');

    res.done({ success: true, path: fullPath });
  });

  // 更新 YAML 文件
  use('yaml/update', function (req, res) {
    const { path: filePath, content } = req.body;

    if (!filePath) {
      // Use res.send for error responses consistent with other parts
      return res.send(400, JSON.stringify({ error: '文件路径不能为空' }));
    }

    const fullPath = path.join(hexo.base_dir, filePath);

    // 检查文件是否存在
    if (!fs.existsSync(fullPath)) {
      // Use res.send for error responses
      return res.send(404, JSON.stringify({ error: '文件不存在' }));
    }

    try {
      // 写入文件
      fs.writeFileSync(fullPath, content || '');

      // --- 修改：扩展主题配置文件的判断逻辑 ---
      const themeName = hexo.config.theme; // 获取当前主题名称
      const normalizedFullPath = path.normalize(fullPath);

      // 检查路径1：主题目录内的 _config.yml 或 _config.yaml
      const themeDirConfigYml = path.normalize(path.join(hexo.theme_dir, '_config.yml'));
      const themeDirConfigYaml = path.normalize(path.join(hexo.theme_dir, '_config.yaml'));

      // 检查路径2：站点根目录的 _config.<theme_name>.yml 或 _config.<theme_name>.yaml
      const rootDirConfigYml = path.normalize(path.join(hexo.base_dir, `_config.${themeName}.yml`));
      const rootDirConfigYaml = path.normalize(path.join(hexo.base_dir, `_config.${themeName}.yaml`));

      // --- 新增：检查站点根目录的 _config.yml ---
      const siteConfigYml = path.normalize(path.join(hexo.base_dir, `_config.yml`));

      const isThemeConfigFile = (
        normalizedFullPath === themeDirConfigYml ||
        normalizedFullPath === themeDirConfigYaml ||
        normalizedFullPath === rootDirConfigYml ||
        normalizedFullPath === rootDirConfigYaml
      );

      // --- 新增：判断是否为站点配置文件 ---
      const isSiteConfigFile = normalizedFullPath === siteConfigYml;


      // --- 修改：处理站点或主题配置文件更新 ---
      if (isThemeConfigFile || isSiteConfigFile) {
        const configType = isThemeConfigFile ? '主题' : '站点';
        hexo.log.info(`${configType}配置文件已更新: ${filePath}. 正在重新加载配置并生成...`);

        // 1. 尝试重新加载内存中的配置 (可选，主要依赖 hexo g)
        try {
          // 对于站点配置，需要重新加载 hexo.config
          if (isSiteConfigFile) {
             // 注意：直接修改 hexo.config 可能不完全生效，hexo g 重新加载更可靠
             const newSiteConfigContent = fse.readFileSync(fullPath, 'utf-8');
             const newSiteConfig = yml.load(newSiteConfigContent);
             // 谨慎合并，避免覆盖核心配置
             // hexo.config = Object.assign({}, hexo.config, newSiteConfig);
             hexo.log.info('站点配置已在内存中尝试更新 (效果依赖 hexo g)。');
          }
          // 对于主题配置
          if (isThemeConfigFile) {
            const newThemeConfigContent = fse.readFileSync(fullPath, 'utf-8');
            const newThemeConfig = yml.load(newThemeConfigContent);
            // 只更新主题配置，不重新初始化整个 Hexo
            hexo.theme.config = Object.assign({}, hexo.theme.config, newThemeConfig);
            hexo.log.info('主题配置已在内存中重新加载。');
          }

        } catch (err) {
          hexo.log.error(`无法在内存中重新加载配置文件 ${filePath}:`, err);
          // 即使内存加载失败，也继续尝试 hexo g
        }

        // 先响应客户端，告知文件已保存成功
        res.done({
          success: true,
          message: `${configType}配置文件已保存成功，正在后台重新生成站点，请稍后刷新页面查看效果。`
        });

        // 2. 在后台异步执行命令行方式重新生成站点
        exec('hexo clean && hexo g', { cwd: hexo.base_dir }, (error, stdout, stderr) => {
          if (error) {
            hexo.log.error(`重新生成站点失败: ${error.message}`);
            hexo.log.error(stderr);
            // 由于已经响应客户端，这里只记录日志，不再发送响应
          } else {
            hexo.log.info(`${configType}配置更新后，站点重新生成成功。`);
            hexo.log.info(stdout);
          }
        });

        // 已经响应客户端，直接返回
        return;
      }

      // 如果不是主题或站点配置文件，仅返回保存成功
      res.done({ success: true, message: '文件保存成功。' });

    } catch (error) {
      hexo.log.error(`更新 YAML 文件 ${filePath} 时出错:`, error);
      // 使用 res.send 返回错误
      res.send(500, JSON.stringify({ error: '更新文件时出错' }));
    }
  });

  // 删除 YAML 文件
  use('yaml/delete', function (req, res) {
    const { path: filePath } = req.body;

    if (!filePath) {
      return res.status(400).json({ error: '文件路径不能为空' });
    }

    const fullPath = path.join(hexo.base_dir, filePath);

    // 检查文件是否存在
    if (!fs.existsSync(fullPath)) {
      return res.status(404).json({ error: '文件不存在' });
    }

    // 删除文件
    fs.unlinkSync(fullPath);

    res.done({ success: true });
  });

  // 获取模板列表
  use('yaml/templates', function (req, res) {
    const templatesPath = path.join(hexo.base_dir, '_yaml_templates');

    // 如果目录不存在，创建它
    if (!fs.existsSync(templatesPath)) {
      fse.ensureDirSync(templatesPath);
      fs.writeFileSync(
        path.join(templatesPath, 'templates.json'),
        JSON.stringify([], null, 2)
      );
      return res.done([]);
    }

    // 读取模板文件
    const templatesFile = path.join(templatesPath, 'templates.json');

    if (!fs.existsSync(templatesFile)) {
      fs.writeFileSync(templatesFile, JSON.stringify([], null, 2));
      return res.done([]);
    }

    const templates = JSON.parse(fse.readFileSync(templatesFile, 'utf-8'));
    res.done(templates);
  });

  // 创建模板
  use('yaml/template/create', function (req, res) {
    const { name, description, structure, variables } = req.body;

    if (!name) {
      return res.status(400).json({ error: '模板名称不能为空' });
    }

    const templatesPath = path.join(hexo.base_dir, '_yaml_templates');
    fse.ensureDirSync(templatesPath);

    const templatesFile = path.join(templatesPath, 'templates.json');

    let templates = [];
    if (fs.existsSync(templatesFile)) {
      templates = JSON.parse(fse.readFileSync(templatesFile, 'utf-8'));
    }

    // 创建新模板
    const newTemplate = {
      id: uuidv4(),
      name,
      description: description || '',
      structure: structure || '', // 确保structure字段正确保存
      variables: variables || [],
      createdAt: new Date().toISOString()
    };

    templates.push(newTemplate);

    // 保存模板
    fs.writeFileSync(templatesFile, JSON.stringify(templates, null, 2));

    res.done(newTemplate);
  });

  // 更新模板
  use('yaml/templates/update', function (req, res) {
    const { id, name, description, structure, variables } = req.body;

    if (!id || !name) {
      return res.status(400).json({ error: '模板ID和名称不能为空' });
    }

    const templatesPath = path.join(hexo.base_dir, '_yaml_templates');
    const templatesFile = path.join(templatesPath, 'templates.json');

    if (!fs.existsSync(templatesFile)) {
      return res.status(404).json({ error: '模板文件不存在' });
    }

    let templates = JSON.parse(fse.readFileSync(templatesFile, 'utf-8'));

    // 查找并更新模板
    const templateIndex = templates.findIndex(t => t.id === id);

    if (templateIndex === -1) {
      return res.status(404).json({ error: '模板不存在' });
    }

    templates[templateIndex] = {
      ...templates[templateIndex],
      name,
      description: description || '',
      structure: structure || '',
      variables: variables || [],
      updatedAt: new Date().toISOString()
    };

    // 保存模板
    fs.writeFileSync(templatesFile, JSON.stringify(templates, null, 2));

    res.done(templates[templateIndex]);
  });

  // 删除模板
  use('yaml/template/delete', function (req, res) {
    const { id } = req.body;

    if (!id) {
      return res.status(400).json({ error: '模板ID不能为空' });
    }

    const templatesPath = path.join(hexo.base_dir, '_yaml_templates');
    const templatesFile = path.join(templatesPath, 'templates.json');

    if (!fs.existsSync(templatesFile)) {
      return res.status(404).json({ error: '模板文件不存在' });
    }

    let templates = JSON.parse(fse.readFileSync(templatesFile, 'utf-8'));

    // 过滤掉要删除的模板
    templates = templates.filter(t => t.id !== id);

    // 保存模板
    fs.writeFileSync(templatesFile, JSON.stringify(templates, null, 2));

    res.done({ success: true });
  });

  // 导入模板
  use('yaml/templates/import', function (req, res) {
    const template = req.body;
    
    if (!template || !template.name) {
      return res.status(400).json({ error: '模板数据无效' });
    }
    
    const templatesPath = path.join(hexo.base_dir, '_yaml_templates');
    fse.ensureDirSync(templatesPath);
    
    const templatesFile = path.join(templatesPath, 'templates.json');
    
    let templates = [];
    if (fs.existsSync(templatesFile)) {
      templates = JSON.parse(fse.readFileSync(templatesFile, 'utf-8'));
    }
    
    // 检查是否存在相同ID的模板
    const existingTemplateIndex = templates.findIndex(t => t.id === template.id);
    
    if (existingTemplateIndex !== -1) {
      // 如果存在相同ID的模板，更新它
      templates[existingTemplateIndex] = {
        ...templates[existingTemplateIndex],
        name: template.name,
        description: template.description || '',
        structure: template.structure || '',
        variables: template.variables || [],
        updatedAt: new Date().toISOString()
      };
    } else {
      // 如果不存在相同ID的模板，创建新模板（确保有唯一ID）
      const newTemplate = {
        id: template.id || uuidv4(), // 使用原ID或生成新ID
        name: template.name,
        description: template.description || '',
        structure: template.structure || '',
        variables: template.variables || [],
        createdAt: new Date().toISOString()
      };
      
      templates.push(newTemplate);
    }
    
    // 保存模板
    fs.writeFileSync(templatesFile, JSON.stringify(templates, null, 2));
    
    res.done({ success: true });
  });

  // 应用模板
  use('yaml/apply-template', function (req, res) {
    const { templateId, values, targetPath, newFilePath } = req.body;

    if (!templateId || !values) {
      return res.status(400).json({ error: '模板ID和变量值不能为空' });
    }

    // 获取模板
    const templatesPath = path.join(hexo.base_dir, '_yaml_templates');
    const templatesFile = path.join(templatesPath, 'templates.json');

    if (!fs.existsSync(templatesFile)) {
      return res.status(404).json({ error: '模板文件不存在' });
    }

    const templates = JSON.parse(fse.readFileSync(templatesFile, 'utf-8'));
    const template = templates.find(t => t.id === templateId);

    if (!template) {
      return res.status(404).json({ error: '模板不存在' });
    }

    // 替换变量
    let content = template.structure;

    // 替换所有 ${variable} 格式的变量
    Object.keys(values).forEach(key => {
      const regex = new RegExp(`\\$\\{${key}\\}`, 'g');
      content = content.replace(regex, values[key]);
    });

    // 确定目标路径
    let finalPath;

    if (targetPath === '__new__' && newFilePath) {
      finalPath = path.join(hexo.base_dir, newFilePath);

      // 确保目录存在
      const dirPath = path.dirname(finalPath);
      fse.ensureDirSync(dirPath);
    } else if (targetPath) {
      finalPath = path.join(hexo.base_dir, targetPath);
    } else {
      return res.status(400).json({ error: '目标路径不能为空' });
    }

    // 写入文件
    fs.writeFileSync(finalPath, content);

    res.done({ success: true, path: finalPath });
  });
};